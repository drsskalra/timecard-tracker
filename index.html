<!DOCTYPE html>
<html lang="en">
<!--
    Time Card Tracker
    Developed by Shashank Singh Kalra, PhD, PE
    LinkedIn: https://www.linkedin.com/in/shashanksinghkalra/
    Email: shashank.kalra@arcadis.com
    Copyright ¬© 2025. All rights reserved.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#366092">
    <meta name="description" content="Professional time tracking application for managing project timecards">
    
    <!-- PWA Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Time Card Tracker">
    <meta name="application-name" content="Time Card Tracker">
    <meta name="msapplication-TileColor" content="#366092">
    <meta name="msapplication-starturl" content="./">
    
    <!-- Manifest and Icons -->
    <link rel="manifest" href="./manifest.json">
    <link rel="icon" type="image/svg+xml" href="./icon-256.svg">
    <link rel="apple-touch-icon" href="./icon-192.svg">
    <link rel="shortcut icon" href="./icon-256.svg">
    
    <title>Time Card Tracker</title>
    <style>
        /* CSS Variables for Light Mode (Default) */
        :root {
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --container-bg: #ffffff;
            --text-color: #212529;
            --text-secondary: #6c757d;
            --header-bg: #366092;
            --header-text: #ffffff;
            --section-bg: #f8f9fa;
            --border-color: #dee2e6;
            --border-light: #e9ecef;
            --input-bg: #ffffff;
            --input-border: #dee2e6;
            --input-focus: #366092;
            --hover-bg: #f8f9fa;
            --table-border: #dee2e6;
            --table-header: #e9ecef;
            --table-hover: #f8f9fa;
            --button-bg: #366092;
            --button-hover: #2a4d73;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --info-color: #17a2b8;
            --warning-color: #ffc107;
            --shadow: rgba(0, 0, 0, 0.1);
            --shadow-hover: rgba(0, 0, 0, 0.15);
        }

        /* Dark Mode */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-gradient-start: #1a1a2e;
                --bg-gradient-end: #16213e;
                --container-bg: #0f1419;
                --text-color: #e4e6eb;
                --text-secondary: #b0b3b8;
                --header-bg: #1e3a5f;
                --header-text: #ffffff;
                --section-bg: #1a1f2e;
                --border-color: #3a3f4b;
                --border-light: #2a2f3b;
                --input-bg: #242933;
                --input-border: #3a3f4b;
                --input-focus: #4a90e2;
                --hover-bg: #242933;
                --table-border: #3a3f4b;
                --table-header: #242933;
                --table-hover: #1e2530;
                --button-bg: #4a90e2;
                --button-hover: #357abd;
                --success-color: #2ea44f;
                --danger-color: #f85149;
                --info-color: #1f9fd8;
                --warning-color: #d29922;
                --shadow: rgba(0, 0, 0, 0.4);
                --shadow-hover: rgba(0, 0, 0, 0.6);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            color: var(--text-color);
        }

        .container {
            width: 100%;
            min-height: 100vh;
            background: var(--container-bg);
            overflow: auto;
        }

        .header {
            background: var(--header-bg);
            color: var(--header-text);
            padding: 30px;
            text-align: center;
        }

        .header .logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
        }

        .header .hourglass-logo {
            width: 60px;
            height: 60px;
            animation: flip 3s ease-in-out infinite;
        }

        @keyframes flip {
            0%, 100% {
                transform: rotate(0deg);
            }
            50% {
                transform: rotate(180deg);
            }
        }

        .header h1 {
            font-size: 2.5em;
            margin: 0;
        }

        .header .week-info {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .timer-section {
            background: var(--section-bg);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 30px;
            border: 2px solid var(--border-light);
        }

        .timer-section h2 {
            color: var(--button-bg);
            margin-bottom: 10px;
            font-size: 1.3em;
            text-align: center;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .form-group {
            margin-bottom: 0;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--text-color);
            font-size: 0.85em;
        }

        .form-group label .history-count {
            font-weight: normal;
            font-size: 0.8em;
            color: var(--text-secondary);
            font-style: italic;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 2px solid var(--input-border);
            border-radius: 5px;
            font-size: 0.9em;
            transition: border-color 0.3s;
            background: var(--input-bg);
            color: var(--text-color);
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--input-focus);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 36px;
            height: 36px;
        }

        .comment-suggestions {
            position: relative;
        }

        .comment-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background: var(--input-bg);
            border: 2px solid var(--input-focus);
            border-radius: 5px;
            box-shadow: 0 4px 6px var(--shadow);
            z-index: 1000;
            display: none;
        }

        .comment-dropdown.show {
            display: block;
        }

        .comment-option {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-light);
            transition: background-color 0.2s;
            color: var(--text-color);
        }

        .comment-option:last-child {
            border-bottom: none;
        }

        .comment-option:hover {
            background-color: var(--hover-bg);
        }

        .comment-option.selected {
            background-color: var(--button-bg);
            color: var(--header-text);
        }

        .timer-display {
            text-align: center;
            padding: 15px;
            background: var(--input-bg);
            border-radius: 8px;
            margin: 10px 0;
        }

        .timer-display .time {
            font-size: 2.5em;
            font-weight: bold;
            color: var(--button-bg);
            font-family: 'Courier New', monospace;
        }

        .timer-display .status {
            font-size: 0.95em;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .btn {
            flex: 1;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary {
            background: var(--success-color);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #218838;
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c82333;
        }

        .btn-warning {
            background: var(--warning-color);
            color: #000;
        }

        .btn-warning:hover:not(:disabled) {
            background: #e0a800;
        }

        .btn-info {
            background: var(--info-color);
            color: white;
        }

        .btn-info:hover {
            background: #138496;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .summary-section {
            margin-top: 30px;
        }

        .summary-section h2 {
            color: #366092;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .timecard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: var(--container-bg);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px var(--shadow);
        }

        .timecard-table th {
            background: var(--header-bg);
            color: var(--header-text);
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        .timecard-table td {
            padding: 12px 15px;
            border-bottom: 1px solid var(--table-border);
            color: var(--text-color);
        }

        .timecard-table tr:last-child td {
            border-bottom: none;
        }

        .timecard-table tr:hover {
            background: var(--table-hover);
        }

        .day-column {
            text-align: center;
            font-size: 0.9em;
        }

        .hours {
            font-weight: 600;
            color: var(--button-bg);
        }

        .comment {
            font-size: 0.85em;
            color: var(--text-secondary);
            font-style: italic;
            display: none;
            margin-top: 5px;
        }

        .comment.show {
            display: block;
        }

        .edit-column {
            width: 50px;
            text-align: center;
            background: var(--section-bg);
            border-right: 3px solid var(--button-bg);
        }

        .edit-column-header {
            background: var(--header-bg) !important;
            opacity: 0.9;
        }

        .edit-mode-active {
            background: var(--hover-bg) !important;
        }

        .inline-edit-input {
            width: 100%;
            padding: 6px 8px;
            border: 2px solid var(--input-border);
            border-radius: 4px;
            font-size: 0.9em;
            background: var(--input-bg);
            color: var(--text-color);
        }

        .inline-edit-input:focus {
            outline: none;
            border-color: var(--success-color);
            box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.2);
        }
        
        .input-with-clear {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .input-clear-btn {
            position: absolute;
            right: 8px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            line-height: 1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .input-clear-btn:hover {
            opacity: 1;
            background: #c82333;
        }

        .inline-edit-actions {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: 8px;
        }

        .inline-edit-btn {
            padding: 5px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all 0.2s;
        }

        .inline-edit-btn.save {
            background: #28a745;
            color: white;
        }

        .inline-edit-btn.save:hover {
            background: #218838;
        }

        .inline-edit-btn.cancel {
            background: #6c757d;
            color: white;
        }

        .inline-edit-btn.cancel:hover {
            background: #5a6268;
        }

        .action-btn {
            background: transparent;
            border: none;
            padding: 4px 6px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.6;
            margin: 0 2px;
        }

        .action-btn:hover {
            opacity: 1;
            transform: scale(1.2);
        }

        .action-btn:active {
            transform: scale(1.1);
        }

        .action-btn.active {
            opacity: 1;
        }

        .edit-input {
            width: 100%;
            padding: 4px;
            border: 2px solid #366092;
            border-radius: 3px;
            font-size: 1em;
            font-family: 'Courier New', monospace;
            text-align: center;
        }

        .edit-input:focus {
            outline: none;
            border-color: #28a745;
        }

        .total-row {
            font-weight: bold;
            background: #f8f9fa !important;
        }

        .current-day {
            background: #28a745;
            color: white !important;
            font-weight: bold;
        }

        .current-day .hours {
            color: white !important;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 30px;
            justify-content: center;
        }

        .hidden {
            display: none;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .alert-success {
            background: var(--success-color);
            color: white;
            border: 1px solid var(--success-color);
            opacity: 0.9;
        }

        .alert-error {
            background: var(--danger-color);
            color: white;
            border: 1px solid var(--danger-color);
            opacity: 0.9;
        }

        .alert-info {
            background: var(--info-color);
            color: white;
            border: 1px solid var(--info-color);
            opacity: 0.9;
        }

        /* Mini floating window */
        .mini-window {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            z-index: 10000;
            min-width: 280px;
            display: none;
            cursor: move;
            user-select: none;
        }

        .mini-window.show {
            display: block;
        }

        .mini-window.always-on-top {
            z-index: 99999;
        }

        .mini-window-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255,255,255,0.3);
        }
        .time-block-record {
            position: absolute;
            top: 6px;
            left: 6px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(255,255,255,0.95);
            color: #dc3545;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            z-index: 6;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        }
        .time-block-record:hover { transform: scale(1.05); background: rgba(255,255,255,0.85); }

        .mini-window-title {
            font-size: 0.9em;
            font-weight: 600;
            opacity: 0.9;
        }

        .mini-window-controls {
            display: flex;
            gap: 8px;
        }

        .mini-window-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .mini-window-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .mini-window-time {
            font-size: 2.5em;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .mini-window-project {
            font-size: 0.9em;
            text-align: center;
            opacity: 0.95;
            margin-top: 10px;
            font-weight: 500;
            line-height: 1.4;
        }

        .mini-window-actions {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        .mini-window-actions button {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mini-window-actions button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .mini-restore-btn {
            background: #28a745;
            color: white;
        }

        .mini-stop-btn {
            background: #dc3545;
            color: white;
        }

        /* Week View Styles */
        .view-toggle {
            display: flex;
            gap: 10px;
        }

        .view-toggle button {
            padding: 8px 16px;
            border: 2px solid var(--button-bg);
            background: var(--container-bg);
            color: var(--button-bg);
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .view-toggle button.active {
            background: var(--button-bg);
            color: var(--header-text);
        }

        #tableViewContainer {
            display: none;
        }

        #tableViewContainer.active {
            display: block;
        }

        .week-view-container {
            display: none;
            background: var(--container-bg);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px var(--shadow);
        }

        .week-view-container.active {
            display: block;
        }

        .calendar-grid {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .day-column {
            flex: 1;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            overflow: hidden;
        }

        .day-header {
            background: var(--header-bg);
            color: var(--header-text);
            padding: 10px;
            text-align: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        .day-header.current {
            background: var(--success-color);
        }

        .timeline {
            position: relative;
            height: 900px;
            background: linear-gradient(to bottom, 
                var(--section-bg) 0%, var(--section-bg) 25%,
                var(--container-bg) 25%, var(--container-bg) 50%,
                var(--section-bg) 50%, var(--section-bg) 75%,
                var(--container-bg) 75%, var(--container-bg) 100%);
        }

        .time-labels {
            position: absolute;
            left: 0;
            top: 0;
            width: 60px;
            height: 100%;
            border-right: 2px solid var(--border-color);
            background: var(--container-bg);
        }

        .time-label {
            position: absolute;
            width: 100%;
            text-align: right;
            padding-right: 5px;
            padding-top: 2px;
            font-size: 0.7em;
            color: var(--text-secondary);
            transform: translateY(0);
        }

        .time-blocks {
            position: absolute;
            left: 65px;
            right: 5px;
            top: 0;
            height: 100%;
            position: absolute;
            /* allow children to use left/width for side-by-side layout */
            overflow: visible;
        }

        .time-block {
            position: absolute;
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            padding: 5px;
            color: white;
            font-size: 0.75em;
            cursor: move;
            transition: box-shadow 0.2s;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            user-select: none;
        }

        .time-block:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .time-block.dragging {
            opacity: 0.7;
            z-index: 100;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .resize-handle {
            position: absolute;
            width: 100%;
            height: 8px;
            cursor: ns-resize;
            z-index: 2;
        }

        .resize-handle.top {
            top: 0;
            cursor: n-resize;
        }

        .resize-handle.bottom {
            bottom: 0;
            cursor: s-resize;
        }

        .resize-handle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .time-blocks.clickable {
            cursor: crosshair;
        }

        .time-block-project {
            font-weight: bold;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .time-block-delete {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 18px;
            height: 18px;
            background: rgba(255, 255, 255, 0.9);
            color: #dc3545;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3;
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
        }

        .time-block-record {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(255,255,255,0.95);
            color: #dc3545;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            z-index: 6;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        }
        .time-block-record:hover { transform: scale(1.05); }

        .time-block:hover .time-block-delete {
            opacity: 1;
        }

        .time-block-delete:hover {
            background: #dc3545;
            color: white;
        }

        .time-block-content {
            cursor: pointer;
            height: 100%;
        }

        .time-block-content:hover {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .time-block-task {
            font-size: 0.9em;
            opacity: 0.9;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .time-block-duration {
            font-size: 0.85em;
            margin-top: 2px;
            font-weight: 600;
        }

        .day-total {
            background: #f8f9fa;
            border-top: 2px solid #366092;
            padding: 10px;
            text-align: center;
            font-weight: bold;
            color: #366092;
        }

        .week-view-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #366092;
        }

        .control-group select,
        .control-group input {
            padding: 5px 10px;
            border: 2px solid #366092;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .control-group button {
            min-width: 100px;
            padding: 8px 16px;
        }

        @media (max-width: 768px) {
            .btn-group {
                flex-direction: column;
            }

            .timecard-table {
                font-size: 0.85em;
            }

            .timer-display .time {
                font-size: 2em;
            }

            .mini-window {
                right: 10px;
                top: 10px;
                min-width: 240px;
            }

            .mini-window-time {
                font-size: 2em;
            }

            .calendar-grid {
                flex-direction: column;
            }

            .timeline {
                height: 600px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo-container">
                <svg class="hourglass-logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <!-- Hourglass frame -->
                    <path d="M20 10 L80 10 L80 15 L70 15 L70 35 L50 50 L70 65 L70 85 L80 85 L80 90 L20 90 L20 85 L30 85 L30 65 L50 50 L30 35 L30 15 L20 15 Z" 
                          fill="none" stroke="white" stroke-width="3"/>
                    
                    <!-- Top sand -->
                    <path d="M32 17 L68 17 L68 33 L50 45 L32 33 Z" fill="#FFD700" opacity="0.9"/>
                    
                    <!-- Bottom sand -->
                    <path d="M32 83 L68 83 L68 67 L50 55 L32 67 Z" fill="#FFD700" opacity="0.9"/>
                    
                    <!-- Center connection -->
                    <circle cx="50" cy="50" r="3" fill="white"/>
                    
                    <!-- Falling sand particles -->
                    <circle cx="48" cy="48" r="1" fill="#FFD700">
                        <animate attributeName="cy" values="48;58;68;78;83" dur="2s" repeatCount="indefinite"/>
                        <animate attributeName="opacity" values="1;1;1;0.5;0" dur="2s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="52" cy="45" r="1" fill="#FFD700">
                        <animate attributeName="cy" values="45;55;65;75;83" dur="2.2s" repeatCount="indefinite"/>
                        <animate attributeName="opacity" values="1;1;1;0.5;0" dur="2.2s" repeatCount="indefinite"/>
                    </circle>
                    <circle cx="50" cy="46" r="1" fill="#FFD700">
                        <animate attributeName="cy" values="46;56;66;76;83" dur="2.1s" repeatCount="indefinite"/>
                        <animate attributeName="opacity" values="1;1;1;0.5;0" dur="2.1s" repeatCount="indefinite"/>
                    </circle>
                </svg>
                <h1>Time Card Tracker</h1>
            </div>
            <div class="week-info">
                Week: <span id="weekDates"></span> | Today: <span id="currentDay"></span>
            </div>
        </div>

        <div class="main-content">
            <div id="alertContainer"></div>

            <!-- Timer Section -->
            <div class="timer-section">
                <div class="timer-display">
                    <div class="time" id="timerDisplay" onclick="editTimerDisplay()" style="cursor: pointer;" title="Click to edit time">00:00:00</div>
                    <div class="status" id="timerStatus">Ready to start (Click time to edit)</div>
                </div>

                <div class="btn-group">
                    <button class="btn btn-primary" id="startBtn" onclick="startTimer()">
                        ‚ñ∂Ô∏è Start Timer
                    </button>
                    <button class="btn btn-danger" id="stopBtn" onclick="stopTimer()" disabled>
                        ‚èπÔ∏è Stop Timer
                    </button>
                    <button class="btn btn-info" id="miniWindowBtn" onclick="toggleMiniWindow()">
                        üìå Picture-in-Picture
                    </button>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="projectNameFilter">
                            Project Name * 
                            <span class="history-count" id="projectNameCount"></span>
                        </label>
                        <input type="text" id="projectNameFilter" placeholder="Enter or select project name" list="projectNameList" required autocomplete="off">
                        <datalist id="projectNameList"></datalist>
                    </div>

                    <div class="form-group">
                        <label for="projectName">
                            Project Number * 
                            <span class="history-count" id="projectCount"></span>
                        </label>
                        <input type="text" id="projectName" placeholder="Enter or select project number" list="projectList" required autocomplete="off">
                        <datalist id="projectList"></datalist>
                    </div>

                    <div class="form-group">
                        <label for="taskName">
                            Task Name * 
                            <span class="history-count" id="taskCount"></span>
                        </label>
                        <input type="text" id="taskName" placeholder="Enter or select task name" list="taskList" required autocomplete="off">
                        <datalist id="taskList"></datalist>
                    </div>

                    <div class="form-group comment-suggestions">
                        <label for="comment">
                            Comment 
                            <span class="history-count" id="commentCount"></span>
                        </label>
                        <textarea id="comment" placeholder="Enter or select comment (click to see suggestions)"></textarea>
                        <div id="commentDropdown" class="comment-dropdown"></div>
                    </div>
                </div>
            </div>

            <!-- Summary Section -->
            <div class="summary-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 style="margin: 0;">üìä Timecard Summary</h2>
                    
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <!-- Week Navigation Arrows -->
                        <button onclick="navigateWeek(-1)" class="btn" style="padding: 5px 12px; font-size: 18px; background: #6c757d; color: white; border: none; cursor: pointer; border-radius: 4px;" title="Previous Week (Left Arrow)">‚óÄ</button>
                        <button onclick="weekOffset = 0; loadData(); loadWeekDates(); updateSummary(); updateWeekView();" class="btn" style="padding: 5px 12px; font-size: 18px; background: #366092; color: white; border: none; cursor: pointer; border-radius: 4px;" title="Current Week (Home Key)">üè†</button>
                        <button onclick="navigateWeek(1)" class="btn" style="padding: 5px 12px; font-size: 18px; background: #6c757d; color: white; border: none; cursor: pointer; border-radius: 4px;" title="Next Week (Right Arrow)">‚ñ∂</button>
                        
                        <!-- View Toggle -->
                        <div class="view-toggle" style="margin: 0;">
                            <button id="tableViewBtn" class="active" onclick="switchView('table')">üìã Table View</button>
                            <button id="weekViewBtn" onclick="switchView('week')">üìÖ Week View</button>
                        </div>
                    </div>
                </div>

                <!-- Table View -->
                <div id="tableViewContainer" class="active">
                    <div id="summaryContainer">
                        <p style="text-align: center; color: #6c757d; padding: 20px;">
                            No time entries recorded yet. Start tracking your time!
                        </p>
                    </div>
                </div>

                <!-- Week View -->
                <div id="weekViewContainer" class="week-view-container">
                    <div class="week-view-controls">
                        <div class="control-group">
                            <label for="startHourSelect">Start Hour:</label>
                            <select id="startHourSelect" onchange="updateWeekView()">
                                <option value="0">12 AM</option>
                                <option value="1">1 AM</option>
                                <option value="2">2 AM</option>
                                <option value="3">3 AM</option>
                                <option value="4">4 AM</option>
                                <option value="5">5 AM</option>
                                <option value="6">6 AM</option>
                                <option value="7">7 AM</option>
                                <option value="8" selected>8 AM</option>
                                <option value="9">9 AM</option>
                                <option value="10">10 AM</option>
                                <option value="11">11 AM</option>
                                <option value="12">12 PM</option>
                                <option value="13">1 PM</option>
                                <option value="14">2 PM</option>
                                <option value="15">3 PM</option>
                                <option value="16">4 PM</option>
                                <option value="17">5 PM</option>
                                <option value="18">6 PM</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="endHourSelect">End Hour:</label>
                            <select id="endHourSelect" onchange="updateWeekView()">
                                <option value="8">8 AM</option>
                                <option value="9">9 AM</option>
                                <option value="10">10 AM</option>
                                <option value="11">11 AM</option>
                                <option value="12">12 PM</option>
                                <option value="13">1 PM</option>
                                <option value="14">2 PM</option>
                                <option value="15">3 PM</option>
                                <option value="16">4 PM</option>
                                <option value="17" selected>5 PM</option>
                                <option value="18">6 PM</option>
                                <option value="19">7 PM</option>
                                <option value="20">8 PM</option>
                                <option value="21">9 PM</option>
                                <option value="22">10 PM</option>
                                <option value="23">11 PM</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <button class="btn btn-secondary" onclick="setWorkHours()">All Day</button>
                            <button class="btn btn-secondary" onclick="setFirstHalf()">1<sup>st</sup>Half</button>
                            <button class="btn btn-secondary" onclick="setSecondHalf()">2<sup>nd</sup>Half</button>
                        </div>
                    </div>
                    <div class="calendar-grid" id="calendarGrid">
                        <!-- Days will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Quick Tips -->
            <div style="margin-bottom: 15px;">
                <button onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'; this.textContent = this.nextElementSibling.style.display === 'none' ? 'üí° Show Quick Tips' : 'üí° Hide Quick Tips';" 
                        style="padding: 8px 16px; background: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 14px;">
                    üí° Show Quick Tips
                </button>
                <div class="alert alert-info" style="margin-top: 10px; display: none; line-height: 1.8;">
                    <strong>‚è±Ô∏è Timer:</strong> Comment required before start/resume ‚Ä¢ Smart history selection<br>
                    <strong>üìù Table View:</strong> ‚úèÔ∏è Click to edit inline ‚Ä¢ Edit time blocks directly ‚Ä¢ Click any cell to copy ‚Ä¢ ‚ñ∂Ô∏è Resume ‚Ä¢ üóëÔ∏è Delete<br>
                    <strong>‚å®Ô∏è Keyboard:</strong> ESC = Cancel edit ‚Ä¢ Ctrl+Enter = Save changes<br>
                    <strong>üïê Time Blocks:</strong> + Add Block ‚Ä¢ Edit start/end times ‚Ä¢ ‚úï Remove blocks ‚Ä¢ Auto-calculated totals<br>
                    <strong>üìÖ Week View:</strong> Click timeline to add ‚Ä¢ Drag to move ‚Ä¢ Resize handles ‚Ä¢ Click blocks to edit/delete ‚Ä¢ Zoom: All Day/1<sup>st</sup> Half/2<sup>nd</sup> Half
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="btn btn-info" onclick="exportToExcel()">
                    üíæ Export Current Week
                </button>
                <button class="btn btn-info" onclick="exportAllWeeksToExcel()">
                    üìä Export All Weeks
                </button>
                <button class="btn btn-primary" onclick="document.getElementById('importFile').click()">
                    üì• Import Data from Previous Export
                </button>
                    <button class="btn btn-primary" onclick="document.getElementById('importIcs').click()">
                        üìÖ Import from Outlook (.ics)
                    </button>
                <button class="btn btn-warning" onclick="openHistoryEditor()">
                    ‚úèÔ∏è Edit History
                </button>
            </div>

            <!-- Hidden file input for import -->
            <input type="file" id="importFile" accept=".xlsx,.xls" style="display: none;" onchange="importFromExcel(event)">
            <input type="file" id="importIcs" accept=".ics,text/calendar" style="display: none;" onchange="importFromICS(event)">

            <!-- Copyright Footer -->
            <div style="text-align: center; margin-top: 30px; padding: 20px; color: #6c757d; font-size: 0.9em; border-top: 1px solid #dee2e6;">
                <p style="margin: 0;">Developed by <strong>Shashank Singh Kalra, PhD, PE</strong></p>
                <p style="margin: 10px 0;">
                    <a href="https://www.linkedin.com/in/shashanksinghkalra/" target="_blank" title="LinkedIn Profile" style="text-decoration: none; margin: 0 10px; display: inline-block;">
                        <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <rect width="32" height="32" rx="4" fill="#0A66C2"/>
                            <path d="M11.5 13.5H8.5V23.5H11.5V13.5Z" fill="white"/>
                            <path d="M10 12C11.1046 12 12 11.1046 12 10C12 8.89543 11.1046 8 10 8C8.89543 8 8 8.89543 8 10C8 11.1046 8.89543 12 10 12Z" fill="white"/>
                            <path d="M23.5 23.5H20.5V18C20.5 16.6193 19.3807 15.5 18 15.5C16.6193 15.5 15.5 16.6193 15.5 18V23.5H12.5V13.5H15.5V14.8C16.1 13.9 17.5 13.2 18.5 13.2C21.5 13.2 23.5 15.2 23.5 18V23.5Z" fill="white"/>
                        </svg>
                    </a>
                    <a href="https://github.com/drsskalra" target="_blank" title="GitHub Profile" style="text-decoration: none; margin: 0 10px; display: inline-block;">
                        <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <rect width="32" height="32" rx="4" fill="#24292e"/>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M16 8C11.58 8 8 11.58 8 16C8 19.54 10.29 22.53 13.47 23.59C13.87 23.66 14.02 23.42 14.02 23.21C14.02 23.02 14.01 22.39 14.01 21.72C12 22.15 11.48 21.12 11.32 20.59C11.23 20.31 10.84 19.6 10.5 19.41C10.22 19.27 9.82 18.84 10.49 18.83C11.12 18.82 11.57 19.46 11.72 19.7C12.44 20.94 13.59 20.6 14.05 20.39C14.12 19.87 14.33 19.53 14.56 19.33C12.84 19.13 11.04 18.45 11.04 15.37C11.04 14.47 11.23 13.73 11.74 13.15C11.66 12.95 11.38 12.14 11.82 11.03C11.82 11.03 12.49 10.82 14.02 11.87C14.66 11.69 15.34 11.6 16.02 11.6C16.7 11.6 17.38 11.69 18.02 11.87C19.55 10.81 20.22 11.03 20.22 11.03C20.66 12.14 20.38 12.95 20.3 13.15C20.81 13.73 21 14.46 21 15.37C21 18.46 19.19 19.13 17.47 19.33C17.76 19.58 18.01 20.06 18.01 20.82C18.01 21.93 18 22.82 18 23.21C18 23.42 18.15 23.67 18.55 23.59C21.71 22.53 24 19.53 24 16C24 11.58 20.42 8 16 8Z" fill="white"/>
                        </svg>
                    </a>
                    <a href="mailto:shashank.kalra@arcadis.com" title="Email" style="text-decoration: none; margin: 0 10px; display: inline-block;">
                        <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <rect width="32" height="32" rx="4" fill="#0078D4"/>
                            <path d="M6 10L16 17L26 10V9C26 8.44772 25.5523 8 25 8H7C6.44772 8 6 8.44772 6 9V10Z" fill="white"/>
                            <path d="M6 12V23C6 23.5523 6.44772 24 7 24H25C25.5523 24 26 23.5523 26 23V12L16 19L6 12Z" fill="white"/>
                        </svg>
                    </a>
                </p>
                <p style="margin: 5px 0 0 0;">¬© 2025. All rights reserved.</p>
            </div>
        </div>
    </div>

    <!-- Mini Floating Window -->
    <div id="miniWindow" class="mini-window">
        <div class="mini-window-header">
            <div class="mini-window-title">Time Card Tracker</div>
            <div class="mini-window-controls">
                <button class="mini-window-btn" onclick="toggleAlwaysOnTop()" title="Toggle Always On Top" id="pinBtn">üìå</button>
                <button class="mini-window-btn" onclick="toggleMiniWindow()" title="Restore">üîΩ</button>
            </div>
        </div>
        <div class="mini-window-time" id="miniTimerDisplay">00:00:00</div>
        <div class="mini-window-project" id="miniProjectInfo">No timer running</div>
        <div class="mini-window-actions">
            <button class="mini-restore-btn" onclick="toggleMiniWindow()">Restore</button>
            <button class="mini-stop-btn" onclick="stopTimer()" id="miniStopBtn" disabled>Stop</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        /**
         * Time Card Tracker - JavaScript
         * Developed by Shashank Singh Kalra, PhD, PE
         * LinkedIn: https://www.linkedin.com/in/shashanksinghkalra/
         * Email: shashank.kalra@arcadis.com
         * Copyright ¬© 2025. All rights reserved.
         */

        // Global variables
        let timerInterval = null;
        let startTime = null;
        let manualTimeOffset = 0; // Offset in seconds for manually set time
        let isContinuingLastBlock = false; // Track if user chose to continue from last time block
        let timeEntries = [];
        const STORAGE_KEY = 'timecard_data';
        const ALL_WEEKS_KEY = 'timecard_all_weeks';
        const HISTORY_KEY = 'timecard_history';
        const LAST_TASK_KEY = 'timecard_last_task';
        const INSTANCE_KEY = 'timecard_instance_id';
        const HEARTBEAT_KEY = 'timecard_instance_heartbeat';
        let projectNameHistory = new Set();
        let projectHistory = new Set();
        let taskHistory = new Set();
        let commentHistory = new Set();
        let instanceId = null;
        let heartbeatInterval = null;
        let miniWindowActive = false;
        let alwaysOnTop = false;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        // Interval used to refresh week view while a timer is active
        let weekViewRefreshInterval = null;
        
        // Week navigation
        let weekOffset = 0; // 0 = current week, -1 = last week, +1 = next week
        
        // Structured history to track relationships
        let structuredHistory = {};
        
        // Last active task (for quick restart)
        let lastActiveTask = null;

        // Initialize on page load
        window.onload = function() {
            // Check for existing instance
            if (!enforceSingleInstance()) {
                return; // Another instance exists, this one will close
            }
            
            loadWeekDates();
            loadHistory();
            loadData();
            loadLastTask(); // Load last active task from previous session
            populateHistoryFromEntries(); // Add history from current entries
            updateSummary();
            updateDropdowns();
            setupInputListeners();
            setupPageProtection();
            registerServiceWorker(); // Register service worker for PWA
            setupIdleNotifications(); // Setup idle timer notifications
            setupMiniWindowDrag(); // Setup mini window dragging
            setupWeekNavigation(); // Setup keyboard shortcuts for week navigation
        };

        // Enforce single instance - prevent multiple tabs/windows
        function enforceSingleInstance() {
            // Generate unique instance ID
            instanceId = 'instance_' + Date.now() + '_' + Math.random();
            
            // Check if another instance exists
            const existingInstanceId = localStorage.getItem(INSTANCE_KEY);
            const lastHeartbeat = parseInt(localStorage.getItem(HEARTBEAT_KEY)) || 0;
            const now = Date.now();
            
            // If another instance exists and is active (heartbeat within last 3 seconds)
            if (existingInstanceId && existingInstanceId !== instanceId && (now - lastHeartbeat) < 3000) {
                // Another instance is running - close this one immediately
                window.close();
                
                // If window.close() doesn't work (e.g., not opened by script), redirect to blank
                setTimeout(() => {
                    window.location = 'about:blank';
                }, 100);
                
                return false;
            }
            
            // This is the active instance
            localStorage.setItem(INSTANCE_KEY, instanceId);
            localStorage.setItem(HEARTBEAT_KEY, now.toString());
            
            // Send heartbeat every second
            heartbeatInterval = setInterval(() => {
                localStorage.setItem(HEARTBEAT_KEY, Date.now().toString());
            }, 1000);
            
            // Clean up on window close/unload
            window.addEventListener('beforeunload', () => {
                const currentInstanceId = localStorage.getItem(INSTANCE_KEY);
                if (currentInstanceId === instanceId) {
                    localStorage.removeItem(INSTANCE_KEY);
                    localStorage.removeItem(HEARTBEAT_KEY);
                }
                if (heartbeatInterval) {
                    clearInterval(heartbeatInterval);
                }
            });
            
            // Listen for storage events (another tab trying to become active)
            window.addEventListener('storage', (e) => {
                if (e.key === INSTANCE_KEY) {
                    const currentInstanceId = localStorage.getItem(INSTANCE_KEY);
                    // If another instance took over, close this one
                    if (currentInstanceId && currentInstanceId !== instanceId) {
                        clearInterval(heartbeatInterval);
                        window.close();
                        setTimeout(() => {
                            window.location = 'about:blank';
                        }, 100);
                    }
                }
            });
            
            return true;
        }

        // Setup idle notifications
        let idleNotificationInterval = null;
        let notificationPermissionRequested = false;

        function setupIdleNotifications() {
            // Request notification permission
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        notificationPermissionRequested = true;
                        startIdleCheck();
                    }
                });
            } else if (Notification.permission === 'granted') {
                notificationPermissionRequested = true;
                startIdleCheck();
            }

            // Also start checking even if permission denied (will show in-app alerts)
            if (Notification.permission === 'denied') {
                startIdleCheck();
            }
        }

        function startIdleCheck() {
            // Check every 5 minutes if timer is not running
            idleNotificationInterval = setInterval(() => {
                if (startTime === null) {
                    // Timer is not running
                    showIdleNotification();
                }
            }, 5 * 60 * 1000); // 5 minutes
        }

        function showIdleNotification() {
            // Check if document is hidden (user is not actively viewing)
            if (document.hidden) {
                // Try desktop notification
                if ('Notification' in window && Notification.permission === 'granted') {
                    const notification = new Notification('Time Card Tracker', {
                        body: 'Working on something? Start Timer',
                        icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgdmlld0JveD0iMCAwIDIwMCAyMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjIwMCIgaGVpZ2h0PSIyMDAiIHJ4PSIxNSIgZmlsbD0iIzM2NjA5MiIvPjxwYXRoIGQ9Ik0yMCAxMCBMODAgMTAgTDgwIDE1IEw3MCAxNSBMNzAgMzUgTDUwIDUwIEw3MCA2NSBMNzAgODUgTDgwIDg1IEw4MCA5MCBMMjAgOTAgTDIwIDg1IEwzMCA4NSBMMzAgNjUgTDUwIDUwIEwzMCAzNSBMMzAgMTUgTDIwIDE1IFoiIGZpbGw9Im5vbmUiIHN0cm9rZT0id2hpdGUiIHN0cm9rZS13aWR0aD0iODYiLz48cGF0aCBkPSJNMzIgMTcgTDY4IDE3IEw2OCAzMyBMNTAgNDUgTDMyIDMzIFoiIGZpbGw9IiM2Q0Y0QzAiIG9wYWNpdHk9IjAuOSIvPjxwYXRoIGQ9Ik0zMiA4MyBMNjggODMgTDY4IDY3IEw1MCA1NSBMMzIgNjcgWiIgZmlsbD0iIzZDRjRDMCIgb3BhY2l0eT0iMC45Ii8+PGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iMyIgZmlsbD0id2hpdGUiLz48dGV4dCB4PSIxMDAiIHk9Ijk1IiBmaWxsPSJ3aGl0ZSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjI0IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj48dHNwYW4+T2N0PC90c3Bhbj48L3RleHQ+PHJlY3QgeD0iOTAiIHk9IjQwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjYwIiByeD0iNSIgZmlsbD0iIzY2NmVlYSIgLz48cmVjdCB4PSI5MCIgeT0iNjAiIHdpZHRoPSI1MCIgaGVpZ2h0PSI0MCIgcng9IjUiIGZpbGw9IiM3NjRiYTIiIC8+PC9zdmc+',
                        badge: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzIiIGhlaWdodD0iNzIiIHZpZXdCb3g9IjAgMCA3MiA3MiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIzNiIgY3k9IjM2IiByPSIzNiIgZmlsbD0iIzM2NjA5MiIvPjwvc3ZnPg==',
                        requireInteraction: true,
                        tag: 'timer-reminder',
                        priority: 'high',
                        silent: false,
                        vibrate: [200, 100, 200]
                    });

                    notification.onclick = function() {
                        window.focus();
                        notification.close();
                    };
                }
            } else {
                // User is viewing the page, show subtle in-app notification
                const alertDiv = document.getElementById('alertContainer');
                if (alertDiv && !alertDiv.querySelector('.reminder-alert')) {
                    const reminderDiv = document.createElement('div');
                    reminderDiv.className = 'alert alert-info reminder-alert';
                    reminderDiv.innerHTML = `
                        <strong>‚è∞ Reminder:</strong> No timer is running. Working on something? 
                        <button onclick="document.getElementById('projectNameFilter').focus()" 
                                style="margin-left: 10px; padding: 5px 15px; background: #366092; color: white; 
                                       border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            Start Timer
                        </button>
                        <button onclick="this.parentElement.remove()" 
                                style="margin-left: 10px; padding: 5px 15px; background: #6c757d; color: white; 
                                       border: none; border-radius: 5px; cursor: pointer;">
                            Dismiss
                        </button>
                    `;
                    alertDiv.innerHTML = '';
                    alertDiv.appendChild(reminderDiv);
                    
                    // Auto-remove after 30 seconds
                    setTimeout(() => {
                        if (reminderDiv.parentElement) {
                            reminderDiv.remove();
                        }
                    }, 30000);
                }
            }
        }

        // Register service worker for PWA installation
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                // Create inline service worker
                const swCode = `
                    self.addEventListener('install', (event) => {
                        self.skipWaiting();
                    });
                    
                    self.addEventListener('activate', (event) => {
                        event.waitUntil(clients.claim());
                    });
                    
                    self.addEventListener('fetch', (event) => {
                        // Let the browser handle all requests normally
                        event.respondWith(fetch(event.request));
                    });
                `;
                
                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);
                
                navigator.serviceWorker.register(swUrl)
                    .then(registration => {
                        console.log('Service Worker registered successfully');
                    })
                    .catch(error => {
                        console.log('Service Worker registration failed:', error);
                    });
            }
        }

        // Get week dates (Monday to Friday)
        function getWeekDates() {
            const today = new Date();
            const dayOfWeek = today.getDay();
            const monday = new Date(today);
            
            // Adjust to get Monday (0 = Sunday, 1 = Monday)
            const daysToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
            monday.setDate(today.getDate() + daysToMonday);
            
            // Apply week offset (7 days per week)
            monday.setDate(monday.getDate() + (weekOffset * 7));
            
            const friday = new Date(monday);
            friday.setDate(monday.getDate() + 4);
            
            return { monday, friday };
        }

        // Load and display week dates
        function loadWeekDates() {
            const { monday, friday } = getWeekDates();
            const formatDate = (date) => {
                return `${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}-${date.getFullYear()}`;
            };
            
            let weekText = `${formatDate(monday)} to ${formatDate(friday)}`;
            const weekDatesElement = document.getElementById('weekDates');
            
            if (weekOffset !== 0) {
                weekText += weekOffset < 0 ? ` (${Math.abs(weekOffset)} week${Math.abs(weekOffset) > 1 ? 's' : ''} ago)` : ` (${weekOffset} week${weekOffset > 1 ? 's' : ''} ahead)`;
                weekDatesElement.style.color = '#ff9800';
                weekDatesElement.style.fontWeight = 'bold';
            } else {
                weekDatesElement.style.color = '';
                weekDatesElement.style.fontWeight = '';
            }
            weekDatesElement.textContent = weekText;
            
            const today = new Date();
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dayName = days[today.getDay()];
            const currentDayText = `${dayName}, ${formatDate(today)}`;
            document.getElementById('currentDay').textContent = currentDayText;
        }

        // Navigate between weeks
        function navigateWeek(direction) {
            weekOffset += direction;
            
            // Load data for the selected week
            const { monday } = getWeekDates();
            const weekKey = monday.toISOString().split('T')[0];
            const allWeeks = getAllWeeks();
            
            if (allWeeks[weekKey]) {
                timeEntries = allWeeks[weekKey].entries || [];
            } else {
                timeEntries = [];
            }
            
            // Update displays
            loadWeekDates();
            updateSummary();
            updateWeekView();
        }

        // Setup week navigation keyboard shortcuts
        function setupWeekNavigation() {
            document.addEventListener('keydown', function(e) {
                // Only handle if not typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                // Left arrow or Ctrl+Left: Previous week
                if ((e.key === 'ArrowLeft' && e.ctrlKey) || (e.key === 'ArrowLeft' && !e.shiftKey && !e.altKey)) {
                    e.preventDefault();
                    navigateWeek(-1);
                }
                // Right arrow or Ctrl+Right: Next week
                else if ((e.key === 'ArrowRight' && e.ctrlKey) || (e.key === 'ArrowRight' && !e.shiftKey && !e.altKey)) {
                    e.preventDefault();
                    navigateWeek(1);
                }
                // Home key: Return to current week
                else if (e.key === 'Home' && weekOffset !== 0) {
                    e.preventDefault();
                    weekOffset = 0;
                    loadData();
                    loadWeekDates();
                    updateSummary();
                    updateWeekView();
                }
            });
        }

        // Get current weekday (1=Monday, 5=Friday)
        function getCurrentWeekday() {
            const today = new Date();
            const dayOfWeek = today.getDay();
            // Convert Sunday=0 to Monday=1 format
            if (dayOfWeek === 0) return 5; // Sunday -> Friday
            if (dayOfWeek === 6) return 5; // Saturday -> Friday
            return dayOfWeek; // Monday=1, ..., Friday=5
        }

        // Format seconds to HH:MM:SS
        function formatSecondsToHHMMSS(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Parse HH:MM:SS to seconds
        function parseHHMMSSToSeconds(timeString) {
            if (!timeString || timeString === '00:00:00') return 0;
            const parts = timeString.split(':');
            if (parts.length !== 3) return 0;
            const hours = parseInt(parts[0]) || 0;
            const minutes = parseInt(parts[1]) || 0;
            const seconds = parseInt(parts[2]) || 0;
            return hours * 3600 + minutes * 60 + seconds;
        }

        // Convert HH:MM:SS to decimal hours
        function convertToDecimalHours(timeString) {
            const seconds = parseHHMMSSToSeconds(timeString);
            return (seconds / 3600).toFixed(2);
        }

        // Format time to HH:MM AM/PM
        function formatClockTime(date) {
            let hours = date.getHours();
            let minutes = date.getMinutes();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // 0 should be 12
            minutes = minutes < 10 ? '0' + minutes : minutes;
            return hours + ':' + minutes + ' ' + ampm;
        }

        // Start timer
        // Prompt for comment with smart selection from history
        // Helper function to show confirm dialog in the appropriate window (main or PiP)
        function showConfirmDialog(message, targetWindow = window) {
            return new Promise((resolve) => {
                const dialog = targetWindow.document.createElement('div');
                dialog.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;

                const content = targetWindow.document.createElement('div');
                content.style.cssText = `
                    background: white;
                    padding: clamp(6px, 2vw, 10px);
                    border-radius: 4px;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
                    max-width: min(400px, 95vw);
                    width: auto;
                    max-height: 95vh;
                `;

                const title = targetWindow.document.createElement('h3');
                title.textContent = 'Resume Timer';
                title.style.cssText = 'margin: 0 0 clamp(6px, 1.5vw, 8px) 0; color: #366092; font-size: clamp(12px, 2.5vw, 14px); font-weight: 600; text-align: center;';

                const buttonWrapper = targetWindow.document.createElement('div');
                buttonWrapper.style.cssText = 'display: flex; gap: clamp(4px, 1.5vw, 6px); justify-content: center;';

                const cancelBtn = targetWindow.document.createElement('button');
                cancelBtn.textContent = 'Start New';
                cancelBtn.style.cssText = `
                    padding: clamp(5px, 1.5vw, 7px) clamp(10px, 2.5vw, 14px);
                    background: #6c757d;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: clamp(11px, 2.5vw, 12px);
                    white-space: nowrap;
                `;
                cancelBtn.onclick = () => {
                    dialog.remove();
                    resolve(false);
                };

                const okBtn = targetWindow.document.createElement('button');
                okBtn.textContent = 'Continue';
                okBtn.style.cssText = `
                    padding: clamp(5px, 1.5vw, 7px) clamp(10px, 2.5vw, 14px);
                    background: #366092;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: clamp(11px, 2.5vw, 12px);
                    white-space: nowrap;
                `;
                okBtn.onclick = () => {
                    dialog.remove();
                    resolve(true);
                };

                buttonWrapper.appendChild(cancelBtn);
                buttonWrapper.appendChild(okBtn);

                content.appendChild(title);
                content.appendChild(buttonWrapper);

                dialog.appendChild(content);
                targetWindow.document.body.appendChild(dialog);
            });
        }

        function promptForComment(currentComment, projectNameFilter, projectNumber, task, targetWindow = window) {
            return new Promise((resolve) => {
                // Get comments from structured history for this project
                let comments = [];
                if (projectNameFilter && structuredHistory[projectNameFilter]) {
                    comments = Array.from(structuredHistory[projectNameFilter].comments);
                }
                // If no project-specific comments, use global comment history
                if (comments.length === 0) {
                    comments = Array.from(commentHistory);
                }
                
                // Sort comments alphabetically
                comments.sort();

                // Get the last comment used (from history if not provided)
                let defaultComment = currentComment;
                if (!defaultComment && comments.length > 0) {
                    // Use the first comment from history (most recent based on how we store it)
                    defaultComment = comments[comments.length - 1];
                }

                // Create modal dialog
                const dialog = targetWindow.document.createElement('div');
                dialog.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;

                const content = targetWindow.document.createElement('div');
                content.style.cssText = `
                    background: white;
                    padding: clamp(6px, 2vw, 10px);
                    border-radius: 4px;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
                    max-width: min(400px, 95vw);
                    width: 95%;
                    max-height: 95vh;
                    overflow-y: auto;
                `;

                const title = targetWindow.document.createElement('h3');
                title.textContent = 'Comment Required';
                title.style.cssText = 'margin: 0 0 clamp(5px, 1.5vw, 8px) 0; color: #366092; font-size: clamp(12px, 2.5vw, 14px); font-weight: 600;';

                const inputWrapper = targetWindow.document.createElement('div');
                inputWrapper.style.cssText = 'position: relative; margin-bottom: clamp(5px, 1.5vw, 8px);';

                const inputRow = targetWindow.document.createElement('div');
                inputRow.style.cssText = 'display: flex; align-items: center; gap: clamp(4px, 1vw, 6px); margin-bottom: clamp(4px, 1vw, 6px);';

                const input = targetWindow.document.createElement('input');
                input.type = 'text';
                input.value = defaultComment;
                input.placeholder = 'Type or select...';
                input.style.cssText = `
                    flex: 1;
                    padding: clamp(5px, 1.5vw, 7px);
                    border: 1px solid #366092;
                    border-radius: 4px;
                    font-size: clamp(11px, 2.5vw, 12px);
                    box-sizing: border-box;
                `;

                // Create dropdown toggle button
                const dropdownBtn = targetWindow.document.createElement('button');
                dropdownBtn.innerHTML = '‚ñº';
                dropdownBtn.style.cssText = `
                    padding: clamp(4px, 1vw, 6px) clamp(6px, 1.5vw, 8px);
                    background: #366092;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: clamp(10px, 2vw, 12px);
                    line-height: 1;
                    min-width: clamp(24px, 5vw, 28px);
                    display: ${comments.length > 0 ? 'block' : 'none'};
                `;

                // Create clear button (X)
                const clearBtn = targetWindow.document.createElement('button');
                clearBtn.innerHTML = '‚úï';
                clearBtn.style.cssText = `
                    padding: clamp(4px, 1vw, 6px) clamp(6px, 1.5vw, 8px);
                    background: #dc3545;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: clamp(14px, 3vw, 16px);
                    line-height: 1;
                    min-width: clamp(24px, 5vw, 28px);
                    display: ${defaultComment ? 'block' : 'none'};
                `;

                // Create dropdown list
                const dropdownList = targetWindow.document.createElement('select');
                dropdownList.size = Math.min(comments.length, 5);
                dropdownList.style.cssText = `
                    width: 100%;
                    padding: clamp(4px, 1vw, 6px);
                    border: 1px solid #366092;
                    border-radius: 4px;
                    font-size: clamp(11px, 2.5vw, 12px);
                    background: white;
                    cursor: pointer;
                    display: none;
                    max-height: 150px;
                `;

                comments.forEach(comment => {
                    const option = targetWindow.document.createElement('option');
                    option.value = comment;
                    option.textContent = comment;
                    dropdownList.appendChild(option);
                });

                // Toggle dropdown visibility
                dropdownBtn.onclick = (e) => {
                    e.preventDefault();
                    dropdownList.style.display = dropdownList.style.display === 'none' ? 'block' : 'none';
                    dropdownBtn.innerHTML = dropdownList.style.display === 'none' ? '‚ñº' : '‚ñ≤';
                };

                // Select from dropdown
                dropdownList.onchange = () => {
                    input.value = dropdownList.value;
                    dropdownList.style.display = 'none';
                    dropdownBtn.innerHTML = '‚ñº';
                    clearBtn.style.display = 'block';
                    input.focus();
                };

                clearBtn.onclick = () => {
                    input.value = '';
                    clearBtn.style.display = 'none';
                    input.focus();
                };

                // Show/hide clear button based on input value
                input.addEventListener('input', () => {
                    clearBtn.style.display = input.value ? 'block' : 'none';
                });

                const buttonWrapper = targetWindow.document.createElement('div');
                buttonWrapper.style.cssText = 'display: flex; gap: clamp(4px, 1.5vw, 6px); justify-content: flex-end;';

                const cancelBtn = targetWindow.document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.style.cssText = `
                    padding: clamp(5px, 1.5vw, 7px) clamp(10px, 2.5vw, 14px);
                    background: #6c757d;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: clamp(11px, 2.5vw, 12px);
                `;
                cancelBtn.onclick = () => {
                    dialog.remove();
                    resolve(null);
                };

                const okBtn = targetWindow.document.createElement('button');
                okBtn.textContent = 'Start';
                okBtn.style.cssText = `
                    padding: clamp(5px, 1.5vw, 7px) clamp(10px, 2.5vw, 14px);
                    background: #366092;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: clamp(11px, 2.5vw, 12px);
                `;
                okBtn.onclick = () => {
                    const value = input.value.trim();
                    if (!value) {
                        input.style.borderColor = 'red';
                        input.focus();
                        return;
                    }
                    dialog.remove();
                    resolve(value);
                };

                // Handle Enter key on input
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        okBtn.click();
                    } else if (e.key === 'Escape') {
                        cancelBtn.click();
                    }
                });

                buttonWrapper.appendChild(cancelBtn);
                buttonWrapper.appendChild(okBtn);

                inputRow.appendChild(input);
                inputRow.appendChild(dropdownBtn);
                inputRow.appendChild(clearBtn);
                
                inputWrapper.appendChild(inputRow);
                if (comments.length > 0) {
                    inputWrapper.appendChild(dropdownList);
                }

                content.appendChild(title);
                content.appendChild(inputWrapper);
                content.appendChild(buttonWrapper);

                dialog.appendChild(content);
                targetWindow.document.body.appendChild(dialog);

                // Focus input and select text
                setTimeout(() => {
                    input.focus();
                    input.select();
                }, 100);
            });
        }

        async function startTimer() {
            // Ensure we're on the current week before starting timer
            if (weekOffset !== 0) {
                const weekMessage = weekOffset < 0 ? 'a past week' : 'a future week';
                showAlert(`Switching from ${weekMessage} to current week to start timer...`, 'info');
                
                // Switch to current week
                weekOffset = 0;
                loadData();
                loadWeekDates();
                updateSummary();
                updateWeekView();
            }
            
            let projectNameFilter = document.getElementById('projectNameFilter').value.trim();
            let project = document.getElementById('projectName').value.trim();
            let task = document.getElementById('taskName').value.trim();
            let comment = document.getElementById('comment').value.trim();

            // If any required field is empty, try to resume from last entry
            if (!projectNameFilter || !project || !task) {
                // First try lastActiveTask (most recently stopped timer)
                if (lastActiveTask && lastActiveTask.projectNameFilter && lastActiveTask.project && lastActiveTask.task) {
                    projectNameFilter = lastActiveTask.projectNameFilter;
                    project = lastActiveTask.project;
                    task = lastActiveTask.task;
                    
                    // Update the form fields
                    document.getElementById('projectNameFilter').value = projectNameFilter;
                    document.getElementById('projectName').value = project;
                    document.getElementById('taskName').value = task;
                    
                    showAlert(`Resuming previous task: ${projectNameFilter} - ${project} - ${task}`, 'info');
                } 
                // If no lastActiveTask, try to get the most recent entry from timeEntries
                else if (timeEntries.length > 0) {
                    const lastEntry = timeEntries[timeEntries.length - 1];
                    projectNameFilter = lastEntry.projectNameFilter || '';
                    project = lastEntry.project || '';
                    task = lastEntry.task || '';
                    
                    // Update the form fields
                    document.getElementById('projectNameFilter').value = projectNameFilter;
                    document.getElementById('projectName').value = project;
                    document.getElementById('taskName').value = task;
                    
                    showAlert(`Starting from last entry: ${projectNameFilter} - ${project} - ${task}`, 'info');
                }
                // Still no data after trying to resume
                else {
                    if (!projectNameFilter) {
                        showAlert('Please enter a project name', 'error');
                        return;
                    }
                    if (!project) {
                        showAlert('Please enter a project number', 'error');
                        return;
                    }
                    if (!task) {
                        showAlert('Please enter a task name', 'error');
                        return;
                    }
                }
            }

            // Check if comment is provided, if not prompt user
            if (!comment) {
                const userComment = await promptForComment('', projectNameFilter, project, task);
                if (userComment === null) {
                    // User cancelled
                    return;
                }
                comment = userComment;
                // Update the comment field
                document.getElementById('comment').value = comment;
            }

            // Save to history
            addToHistory(projectNameFilter, project, task, comment);

            // Save as last active task (for next session restart)
            lastActiveTask = {
                projectNameFilter: projectNameFilter,
                project: project,
                task: task
            };
            saveLastTask(); // Persist to localStorage

            // Calculate start time considering manual offset
            startTime = Date.now() - (manualTimeOffset * 1000);
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('projectNameFilter').disabled = true;
            document.getElementById('projectName').disabled = true;
            document.getElementById('taskName').disabled = true;
            // Keep comment editable while timer is running so user can update it live
            // document.getElementById('comment').disabled = true;
            
            const startClockTime = formatClockTime(new Date(startTime));
            document.getElementById('timerStatus').textContent = `Timer running for ${projectNameFilter} - ${project} - ${task} (Started: ${startClockTime})`;

            timerInterval = setInterval(updateTimerDisplay, 1000);
            // Refresh week view periodically so the running timer is visible
            if (!weekViewRefreshInterval) {
                weekViewRefreshInterval = setInterval(() => {
                    try { updateWeekView(); } catch (e) { /* ignore */ }
                }, 1000); // every 1 second for smooth live update
            }
            showAlert(`Timer started for ${projectNameFilter} - ${project} - ${task} at ${startClockTime}`, 'success');
            
            // Clear any reminder notifications
            const reminderAlert = document.querySelector('.reminder-alert');
            if (reminderAlert) {
                reminderAlert.remove();
            }
            
            // Update mini window if active
            if (miniWindowActive) {
                updateMiniWindowInfo();
            }
        }

        // Auto-stop timer (called when page closes/refreshes)
        function autoStopTimer() {
            if (!startTime) {
                return; // Timer not running
            }

            clearInterval(timerInterval);
            const endTime = Date.now();
            const elapsedSeconds = Math.floor((endTime - startTime) / 1000);
            const elapsedTime = formatSecondsToHHMMSS(elapsedSeconds);

            const projectNameFilter = document.getElementById('projectNameFilter').value.trim();
            const project = document.getElementById('projectName').value.trim();
            const task = document.getElementById('taskName').value.trim();
            const comment = document.getElementById('comment').value.trim();
            const currentDay = getCurrentWeekday();

            // Save as last active task for quick restart on next session
            lastActiveTask = {
                projectNameFilter: projectNameFilter,
                project: project,
                task: task
            };
            saveLastTask(); // Persist to localStorage

            // Format clock times
            const fromTime = formatClockTime(new Date(startTime));
            const toTime = formatClockTime(new Date(endTime));
            const clockTimeRange = `${fromTime} - ${toTime}`;

            // Find or create entry
            let entry = timeEntries.find(e => e.projectNameFilter === projectNameFilter && e.project === project && e.task === task);
            
            if (entry) {
                // Update existing entry - add times
                const existingTime = entry[`day${currentDay}_hr`] || '00:00:00';
                const existingSeconds = parseHHMMSSToSeconds(existingTime);
                const totalSeconds = existingSeconds + elapsedSeconds;
                entry[`day${currentDay}_hr`] = formatSecondsToHHMMSS(totalSeconds);
                
                // Append clock time range
                const existingClockTime = entry[`day${currentDay}_clocktime`] || '';
                if (existingClockTime) {
                    entry[`day${currentDay}_clocktime`] = `${existingClockTime}, ${clockTimeRange}`;
                } else {
                    entry[`day${currentDay}_clocktime`] = clockTimeRange;
                }
                
                const existingComment = entry[`day${currentDay}_comment`] || '';
                if (existingComment && comment) {
                    const existingComments = existingComment.split(';').map(c => c.trim());
                    const newCommentTrimmed = comment.trim();
                    if (!existingComments.includes(newCommentTrimmed)) {
                        entry[`day${currentDay}_comment`] = `${existingComment}; ${comment}`;
                    }
                } else if (comment) {
                    entry[`day${currentDay}_comment`] = comment;
                }
            } else {
                // Create new entry
                entry = { projectNameFilter, project, task };
                for (let i = 1; i <= 5; i++) {
                    entry[`day${i}_hr`] = '00:00:00';
                    entry[`day${i}_comment`] = '';
                    entry[`day${i}_clocktime`] = '';
                }
                entry[`day${currentDay}_hr`] = elapsedTime;
                entry[`day${currentDay}_comment`] = comment;
                entry[`day${currentDay}_clocktime`] = clockTimeRange;
                timeEntries.push(entry);
            }

            // Save data immediately
            saveData();
            updateSummary();
            updateWeekView();
            updateSummary();
            updateWeekView();
            // Clear week view refresh when timer is no longer running
            if (weekViewRefreshInterval) {
                clearInterval(weekViewRefreshInterval);
                weekViewRefreshInterval = null;
            }
        }

        // Stop timer
        function stopTimer() {
            if (!startTime) {
                showAlert('Timer was not started!', 'error');
                return;
            }

            clearInterval(timerInterval);
            const endTime = Date.now();
            const elapsedSeconds = Math.floor((endTime - startTime) / 1000);
            const elapsedTime = formatSecondsToHHMMSS(elapsedSeconds);

            const projectNameFilter = document.getElementById('projectNameFilter').value.trim();
            const project = document.getElementById('projectName').value.trim();
            const task = document.getElementById('taskName').value.trim();
            const comment = document.getElementById('comment').value.trim();
            const currentDay = getCurrentWeekday();

            // Save as last active task for quick restart
            lastActiveTask = {
                projectNameFilter: projectNameFilter,
                project: project,
                task: task
            };
            saveLastTask(); // Persist to localStorage

            // Format clock times
            const fromTime = formatClockTime(new Date(startTime));
            const toTime = formatClockTime(new Date(endTime));
            const clockTimeRange = `${fromTime} - ${toTime}`;

            // Find or create entry - now includes projectNameFilter
            let entry = timeEntries.find(e => e.projectNameFilter === projectNameFilter && e.project === project && e.task === task);
            
            if (entry) {
                // Update existing entry - add times
                const existingTime = entry[`day${currentDay}_hr`] || '00:00:00';
                const existingSeconds = parseHHMMSSToSeconds(existingTime);
                const totalSeconds = existingSeconds + elapsedSeconds;
                entry[`day${currentDay}_hr`] = formatSecondsToHHMMSS(totalSeconds);
                
                // Check if we're continuing from the last block (user's explicit choice)
                const existingClockTime = entry[`day${currentDay}_clocktime`] || '';
                
                if (isContinuingLastBlock && existingClockTime) {
                    // Update the last block's end time instead of adding a new block
                    const blocks = existingClockTime.split(',').map(b => b.trim());
                    const lastBlock = blocks[blocks.length - 1];
                    const [lastStart, lastEnd] = lastBlock.split('-').map(s => s.trim());
                    
                    // Replace the last block with updated end time
                    blocks[blocks.length - 1] = `${lastStart} - ${toTime}`;
                    entry[`day${currentDay}_clocktime`] = blocks.join(', ');
                } else {
                    // Append new clock time range
                    if (existingClockTime) {
                        entry[`day${currentDay}_clocktime`] = `${existingClockTime}, ${clockTimeRange}`;
                    } else {
                        entry[`day${currentDay}_clocktime`] = clockTimeRange;
                    }
                }
                
                // Reset the flag after using it
                isContinuingLastBlock = false;
                
                const existingComment = entry[`day${currentDay}_comment`] || '';
                if (existingComment && comment) {
                    // Check if the new comment already exists in the existing comments
                    const existingComments = existingComment.split(';').map(c => c.trim());
                    const newCommentTrimmed = comment.trim();
                    
                    if (!existingComments.includes(newCommentTrimmed)) {
                        entry[`day${currentDay}_comment`] = `${existingComment}; ${comment}`;
                    }
                    // If comment already exists, don't add it again
                } else if (comment) {
                    entry[`day${currentDay}_comment`] = comment;
                }
            } else {
                // Create new entry
                entry = { projectNameFilter, project, task };
                for (let i = 1; i <= 5; i++) {
                    entry[`day${i}_hr`] = '00:00:00';
                    entry[`day${i}_comment`] = '';
                    entry[`day${i}_clocktime`] = '';
                }
                entry[`day${currentDay}_hr`] = elapsedTime;
                entry[`day${currentDay}_comment`] = comment;
                entry[`day${currentDay}_clocktime`] = clockTimeRange;
                timeEntries.push(entry);
            }

            saveData();
            updateSummary();
            
            // Reset timer UI but keep the form values
            clearInterval(timerInterval);
            startTime = null;
            manualTimeOffset = 0;
            document.getElementById('timerDisplay').textContent = '00:00:00';
            document.getElementById('timerStatus').textContent = 'Ready to start (Click time to edit)';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('projectNameFilter').disabled = false;
            document.getElementById('projectName').disabled = false;
            document.getElementById('taskName').disabled = false;
            document.getElementById('comment').disabled = false;

            const elapsedHours = (elapsedSeconds / 3600).toFixed(2);
            const minutes = (elapsedSeconds / 60).toFixed(1);
            showAlert(`Time recorded: ${elapsedTime} (${elapsedHours} hours / ${minutes} minutes) from ${fromTime} to ${toTime}`, 'success');
            
            // Update mini window if active
            if (miniWindowActive) {
                updateMiniWindowInfo();
            }

            // Clear periodic week view refresh when timer stops
            if (weekViewRefreshInterval) {
                clearInterval(weekViewRefreshInterval);
                weekViewRefreshInterval = null;
            }
        }

        // Update timer display
        function updateTimerDisplay() {
            if (!startTime) return;

            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const hours = Math.floor(elapsed / 3600);
            const minutes = Math.floor((elapsed % 3600) / 60);
            const seconds = elapsed % 60;

            const display = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            document.getElementById('timerDisplay').textContent = display;
            
            // Update mini window if active
            if (miniWindowActive) {
                document.getElementById('miniTimerDisplay').textContent = display;
            }
        }

        // Variables for PiP window
        let pipWindow = null;
        let pipUpdateInterval = null;

        // Toggle mini window with OS Picture-in-Picture support
        async function toggleMiniWindow() {
            // Check if Document Picture-in-Picture API is available
            if ('documentPictureInPicture' in window) {
                // Use OS-level Picture-in-Picture
                if (pipWindow && !pipWindow.closed) {
                    // Close existing PiP window
                    pipWindow.close();
                } else {
                    // Open new OS-level PiP window
                    await openPictureInPicture();
                }
            } else {
                // Fallback to browser-based mini window
                const miniWindow = document.getElementById('miniWindow');
                const mainContainer = document.querySelector('.container');
                
                miniWindowActive = !miniWindowActive;
                
                if (miniWindowActive) {
                    // Show mini window, hide main
                    miniWindow.classList.add('show');
                    mainContainer.style.display = 'none';
                    updateMiniWindowInfo();
                    
                    // Update button text
                    document.getElementById('miniWindowBtn').innerHTML = 'üîΩ Restore';
                } else {
                    // Hide mini window, show main
                    miniWindow.classList.remove('show');
                    mainContainer.style.display = 'block';
                    
                    // Update button text
                    document.getElementById('miniWindowBtn').innerHTML = 'üìå Picture-in-Picture';
                }
            }
        }

        // Open OS-level Picture-in-Picture window
        async function openPictureInPicture() {
            try {
                // Get current project info
                const projectName = document.getElementById('projectNameFilter').value.trim() || 'No Project';
                const projectNumber = document.getElementById('projectName').value.trim() || 'N/A';
                const task = document.getElementById('taskName').value.trim() || 'No Task';
                
                // Calculate total time for this project and task for TODAY ONLY
                let projectTotalSeconds = 0;
                const currentDay = getCurrentWeekday();
                const matchingEntries = timeEntries.filter(e => 
                    e.projectNameFilter === projectName && 
                    e.project === projectNumber &&
                    e.task === task
                );
                // Sum only today's time for matching entries
                matchingEntries.forEach(entry => {
                    projectTotalSeconds += parseHHMMSSToSeconds(entry[`day${currentDay}_hr`] || '00:00:00');
                });
                const projectTotalTime = formatSecondsToHHMMSS(projectTotalSeconds);

                // PiP dimensions (no enforced minimums)
                const PIP_MIN_WIDTH = 0;
                const PIP_MIN_HEIGHT = 0;

                // Open PiP window (requested size)
                pipWindow = await documentPictureInPicture.requestWindow({
                    width: 500,
                    height: 80
                });

                // Create styles for PiP window
                const pipStyles = `
                    <style>
                        * {
                            margin: 0;
                            padding: 0;
                            box-sizing: border-box;
                        }
                        body {
                            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            height: 100vh;
                            width: 100vw;
                            display: flex;
                            flex-direction: column;
                            overflow: hidden;
                        }
                        .pip-content {
                            flex: 1;
                            display: grid;
                            grid-template-columns: 1fr auto auto; /* timers, compact center, record button */
                            align-items: center;
                            padding: 0; /* remove outer padding so controls can sit flush */
                            gap: 0; /* remove gaps between grid columns */
                            min-width: 0;
                            /* allow content to wrap/shrink */
                            min-height: 0;
                            grid-auto-flow: column;
                        }
                        .pip-info {
                            flex: 1 1 auto;
                            display: flex;
                            flex-direction: column;
                            gap: 0.15rem;
                            min-width: 0;
                            overflow: hidden;
                            padding-right: 0.3rem; /* avoid content flowing under right column */
                        }
                        .pip-project-task {
                            font-size: clamp(12px, 1.6vw, 14px);
                            font-weight: 600;
                            line-height: 1.1;
                            white-space: nowrap;
                            overflow: hidden;
                            text-overflow: ellipsis;
                            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                        }
                        .pip-clock-time {
                            font-size: clamp(12px, 1.8vw, 18px);
                            font-weight: 500;
                            color: #90EE90;
                            line-height: 1.1;
                            white-space: nowrap;
                            overflow: hidden;
                            text-overflow: ellipsis;
                            font-family: 'Courier New', monospace;
                        }
                        .pip-timer {
                            font-size: clamp(12px, 1.8vw, 16px);
                            font-weight: 700;
                            font-family: 'Courier New', monospace;
                            text-shadow: 1px 1px 2px rgba(0,0,0,0.25);
                            line-height: 1;
                            white-space: nowrap;
                            flex-shrink: 0;
                        }
                        .pip-today-timer {
                            font-size: clamp(12px, 1.8vw, 16px);
                            font-weight: 700;
                            color: #90EE90;
                            line-height: 1.05;
                            white-space: nowrap;
                            overflow: hidden;
                            text-overflow: ellipsis;
                            font-family: 'Courier New', monospace;
                        }
                        .pip-today-label {
                            font-size: clamp(10px, 1.6vw, 12px);
                            font-weight: 600;
                            color: #90EE90;
                            line-height: 1;
                            white-space: nowrap;
                            overflow: hidden;
                            text-overflow: ellipsis;
                            font-family: 'Courier New', monospace;
                            margin-left: 6px;
                        }
                        .pip-today-timer-value {
                            font-size: clamp(12px, 1.8vw, 16px);
                            font-weight: 700;
                            color: #90EE90;
                            font-family: 'Courier New', monospace;
                            line-height: 1;
                        }
                        .pip-record-btn {
                            min-width: 0;
                            min-height: 0;
                            width: 34px;
                            height: 34px;
                            max-width: 38px;
                            max-height: 38px;
                            border: 2px solid rgba(255,255,255,0.9);
                            border-radius: 50%;
                            background: transparent;
                            cursor: pointer;
                            transition: all 0.18s ease-in-out;
                            position: relative;
                            padding: 0;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            flex-shrink: 0;
                            box-sizing: border-box;
                            z-index: 2;
                        }
                        .pip-content > div:nth-child(2) {
                            display: flex;
                            justify-content: center;
                            align-items: center;
                            min-width: 28px;
                            justify-self: end;
                            padding-right: 4px;
                        }
                        .pip-record-btn:hover {
                            border-color: rgba(255,255,255,1);
                            transform: scale(1.15);
                            box-shadow: 0 0 15px rgba(255,255,255,0.6);
                        }
                        .pip-record-btn.recording {
                            background: #dc3545;
                            border-color: #dc3545;
                            animation: pulse 2s ease-in-out infinite;
                        }
                        .pip-record-btn.recording:hover {
                            background: #c82333;
                            border-color: #c82333;
                            box-shadow: 0 0 20px rgba(220, 53, 69, 0.8);
                        }
                        .pip-record-container {
                            padding: 0 6px 0 0; /* small right padding to avoid touching edge */
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            min-width: 34px;
                        }
                        @keyframes pulse {
                            0%, 100% {
                                opacity: 1;
                                box-shadow: 0 0 10px rgba(220, 53, 69, 0.6);
                            }
                            50% {
                                opacity: 0.85;
                                box-shadow: 0 0 20px rgba(220, 53, 69, 0.9);
                            }
                        }
                        @media (max-width: 600px) {
                            .pip-content {
                                padding: 6px 8px;
                                gap: 6px;
                            }
                            .pip-timer { font-size: clamp(12px, 4.5vw, 20px); }
                            .pip-project-task { font-size: clamp(10px, 4vw, 16px); }
                            .pip-clock-time { font-size: clamp(10px, 3.5vw, 16px); }
                        }
                        .pip-right {
                            display: flex;
                            align-items: center;
                            gap: 0.25rem;
                            flex-shrink: 1;
                            min-width: 46px; /* compact right column */
                        }
                        .pip-timers {
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            gap: 0;
                            min-width: 0;
                        }
                    </style>
                `;

                // Create HTML content for PiP window
                const pipHTML = `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>‚è±Ô∏è Timer</title>
                        ${pipStyles}
                    </head>
                    <body>
                        <div class="pip-content">
                            <div class="pip-info">
                                <div class="pip-project-task" id="pipProjectTask">${projectName}: ${task}</div>
                                <div class="pip-clock-time" id="pipClockTime">--:-- -- - --:-- --</div>
                            </div>
                            <div class="pip-right">
                                <div class="pip-timers">
                                        <div class="pip-timer" id="pipTimer">${projectTotalTime}</div>
                                        <div class="pip-timer pip-today-timer" id="pipDayTotalTimer"></div>
                                    </div>
                            </div>
                            <div class="pip-record-container" style="display:flex;justify-content:center;align-items:center;">
                                <button class="pip-record-btn ${startTime !== null ? 'recording' : ''}" id="pipRecordBtn" onclick="window.opener.toggleTimerFromPip()" title="${startTime !== null ? 'Stop Recording' : 'Start Recording'}"></button>
                            </div>
                        </div>
                    </body>
                    </html>
                `;

                // Write content to PiP window
                pipWindow.document.write(pipHTML);
                pipWindow.document.close();

                // Do not enforce minimum PiP size; let CSS and the host decide resize behavior.

                // Update button text
                document.getElementById('miniWindowBtn').innerHTML = 'üîΩ Close PiP';

                // Update PiP window
                pipUpdateInterval = setInterval(() => {
                    if (pipWindow && !pipWindow.closed) {
                        const pipRecordBtn = pipWindow.document.getElementById('pipRecordBtn');
                        if (startTime !== null) {
                            pipRecordBtn.classList.add('recording');
                            pipRecordBtn.title = 'Stop Recording';
                        } else {
                            pipRecordBtn.classList.remove('recording');
                            pipRecordBtn.title = 'Start Recording';
                        }

                        // Project/task timer for today
                        let projectTotalSeconds = 0;
                        const currentProjectName = document.getElementById('projectNameFilter').value.trim();
                        const currentProjectNumber = document.getElementById('projectName').value.trim();
                        const currentTask = document.getElementById('taskName').value.trim();
                        const currentDay = getCurrentWeekday();
                        const matchingEntries = timeEntries.filter(e => 
                            e.projectNameFilter === currentProjectName && 
                            e.project === currentProjectNumber &&
                            e.task === currentTask
                        );
                        matchingEntries.forEach(entry => {
                            projectTotalSeconds += parseHHMMSSToSeconds(entry[`day${currentDay}_hr`] || '00:00:00');
                        });
                        if (startTime !== null) {
                            const elapsed = Math.floor((Date.now() - startTime) / 1000);
                            projectTotalSeconds += elapsed;
                        }
                        const totalTime = formatSecondsToHHMMSS(projectTotalSeconds);

                        // Today's total timer for all tasks/projects
                        let dayTotalSeconds = 0;
                        timeEntries.forEach(entry => {
                            dayTotalSeconds += parseHHMMSSToSeconds(entry[`day${currentDay}_hr`] || '00:00:00');
                        });
                        // If timer is running, add current elapsed time to today's total
                        if (startTime !== null) {
                            dayTotalSeconds += Math.floor((Date.now() - startTime) / 1000);
                        }
                        const dayTotalTime = formatSecondsToHHMMSS(dayTotalSeconds);

                        // Build display text
                        const displayTaskName = currentTask || 'No Task';
                        const displayProjectName = currentProjectName || 'No Project';
                        const projectTaskText = `${displayProjectName}: ${displayTaskName}`;
                        let clockTimeText = 'Not running';
                        if (startTime !== null) {
                            const startClockTime = formatClockTime(new Date(startTime));
                            const currentClockTime = formatClockTime(new Date());
                            clockTimeText = `${startClockTime} - ${currentClockTime}`;
                        }

                        // Update PiP elements
                        const pipProjectTask = pipWindow.document.getElementById('pipProjectTask');
                        const pipClockTime = pipWindow.document.getElementById('pipClockTime');
                        const pipTimer = pipWindow.document.getElementById('pipTimer');
                        const pipDayTotalTimer = pipWindow.document.getElementById('pipDayTotalTimer');
                        if (pipProjectTask) pipProjectTask.textContent = projectTaskText;
                        if (pipClockTime) pipClockTime.textContent = clockTimeText;
                        if (pipTimer) pipTimer.innerHTML = `${totalTime}`;
                        if (pipDayTotalTimer) pipDayTotalTimer.innerHTML = `<span class="pip-today-timer-value">${dayTotalTime}</span><span class="pip-today-label">(Today)</span>`;
                    } else {
                        clearInterval(pipUpdateInterval);
                        document.getElementById('miniWindowBtn').innerHTML = 'üìå Picture-in-Picture';
                    }
                }, 1000);

                // Handle PiP window close
                pipWindow.addEventListener('pagehide', () => {
                    clearInterval(pipUpdateInterval);
                    pipWindow = null;
                    document.getElementById('miniWindowBtn').innerHTML = 'üìå Picture-in-Picture';
                });

                showAlert('Picture-in-Picture window opened! It will stay on top of other windows.', 'success');

            } catch (error) {
                console.error('Error opening Picture-in-Picture:', error);
                showAlert('Picture-in-Picture not supported in this browser. Using fallback mini window.', 'info');
                
                // Fallback to browser-based mini window
                const miniWindow = document.getElementById('miniWindow');
                const mainContainer = document.querySelector('.container');
                
                miniWindowActive = true;
                miniWindow.classList.add('show');
                mainContainer.style.display = 'none';
                updateMiniWindowInfo();
                document.getElementById('miniWindowBtn').innerHTML = 'üîΩ Restore';
            }
        }

        // Update mini window information
        function updateMiniWindowInfo() {
            const miniTimerDisplay = document.getElementById('miniTimerDisplay');
            const miniProjectInfo = document.getElementById('miniProjectInfo');
            const miniStopBtn = document.getElementById('miniStopBtn');
            
            if (startTime) {
                // Timer is running
                const projectNameFilter = document.getElementById('projectNameFilter').value.trim();
                const project = document.getElementById('projectName').value.trim();
                const task = document.getElementById('taskName').value.trim();
                const startClockTime = formatClockTime(new Date(startTime));
                const currentClockTime = formatClockTime(new Date());
                
                miniProjectInfo.innerHTML = `<strong>${projectNameFilter}</strong><br>${project} - ${task}<br><small style="color: #28a745; font-weight: 600;">${startClockTime} - ${currentClockTime}</small>`;
                miniStopBtn.disabled = false;
                
                // Update time
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const hours = Math.floor(elapsed / 3600);
                const minutes = Math.floor((elapsed % 3600) / 60);
                const seconds = elapsed % 60;
                const display = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                miniTimerDisplay.textContent = display;
            } else {
                miniTimerDisplay.textContent = '00:00:00';
                miniProjectInfo.textContent = 'No timer running';
                miniStopBtn.disabled = true;
            }
        }

        // Toggle always on top
        function toggleAlwaysOnTop() {
            const miniWindow = document.getElementById('miniWindow');
            const pinBtn = document.getElementById('pinBtn');
            
            alwaysOnTop = !alwaysOnTop;
            
            if (alwaysOnTop) {
                miniWindow.classList.add('always-on-top');
                pinBtn.style.background = 'rgba(255,255,255,0.4)';
                pinBtn.title = 'Always On Top (Active)';
            } else {
                miniWindow.classList.remove('always-on-top');
                pinBtn.style.background = 'rgba(255,255,255,0.2)';
                pinBtn.title = 'Toggle Always On Top';
            }
        }

        // Setup draggable mini window
        function setupMiniWindowDrag() {
            const miniWindow = document.getElementById('miniWindow');
            const header = miniWindow.querySelector('.mini-window-header');
            
            header.addEventListener('mousedown', (e) => {
                if (e.target.closest('.mini-window-btn')) return; // Don't drag when clicking buttons
                
                isDragging = true;
                const rect = miniWindow.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                miniWindow.style.cursor = 'grabbing';
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                e.preventDefault();
                
                let newX = e.clientX - dragOffset.x;
                let newY = e.clientY - dragOffset.y;
                
                // Keep within viewport
                const rect = miniWindow.getBoundingClientRect();
                newX = Math.max(0, Math.min(newX, window.innerWidth - rect.width));
                newY = Math.max(0, Math.min(newY, window.innerHeight - rect.height));
                
                miniWindow.style.left = newX + 'px';
                miniWindow.style.top = newY + 'px';
                miniWindow.style.right = 'auto';
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    miniWindow.style.cursor = 'move';
                }
            });
        }

        // Reset timer display to 00:00:00
        function resetTimerDisplay() {
            const isRunning = startTime !== null;
            
            if (isRunning) {
                // Reset running timer to start from 00:00:00 now
                startTime = Date.now();
                document.getElementById('timerStatus').textContent = 'Timer reset and running';
                showAlert('Timer reset to 00:00:00 and continuing', 'info');
            } else {
                // Reset stopped timer
                manualTimeOffset = 0;
                document.getElementById('timerDisplay').textContent = '00:00:00';
                document.getElementById('timerStatus').textContent = 'Ready to start (Click time to edit)';
                showAlert('Timer reset to 00:00:00', 'info');
            }
        }

        // Reset timer (clear form and timer)
        function resetTimer() {
            clearInterval(timerInterval);
            startTime = null;
            manualTimeOffset = 0;
            document.getElementById('timerDisplay').textContent = '00:00:00';
            document.getElementById('timerStatus').textContent = 'Ready to start (Click time to edit)';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('projectNameFilter').disabled = false;
            document.getElementById('projectName').disabled = false;
            document.getElementById('taskName').disabled = false;
            document.getElementById('comment').disabled = false;
            document.getElementById('projectNameFilter').value = '';
            document.getElementById('projectName').value = '';
            document.getElementById('taskName').value = '';
            document.getElementById('comment').value = '';
        }

        // Edit timer display manually
        function editTimerDisplay() {
            const currentTime = document.getElementById('timerDisplay').textContent;
            const isRunning = startTime !== null;
            
            const promptMessage = isRunning 
                ? 'Edit current timer value (format: HH:MM:SS):\n\nTimer is running - you can adjust the time.\n\nExample: 01:30:00 for 1 hour 30 minutes'
                : 'Set timer start value (format: HH:MM:SS):\n\nExample: 01:30:00 for 1 hour 30 minutes';
            
            const newTime = prompt(promptMessage, currentTime);

            if (newTime === null) return; // User cancelled

            // Validate time format
            const timeRegex = /^([0-9]{1,2}):([0-9]{2}):([0-9]{2})$/;
            const match = newTime.trim().match(timeRegex);
            
            if (!match) {
                showAlert('Invalid time format! Use HH:MM:SS (e.g., 01:30:00)', 'error');
                return;
            }

            const hours = parseInt(match[1]);
            const minutes = parseInt(match[2]);
            const seconds = parseInt(match[3]);

            if (minutes >= 60 || seconds >= 60) {
                showAlert('Invalid time! Minutes and seconds must be less than 60', 'error');
                return;
            }

            // Format with leading zeros
            const formattedTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            
            // Calculate offset in seconds
            const newOffset = hours * 3600 + minutes * 60 + seconds;
            
            if (isRunning) {
                // Timer is running - adjust the start time
                const now = Date.now();
                startTime = now - (newOffset * 1000);
                document.getElementById('timerStatus').textContent = `Timer adjusted to ${formattedTime}`;
                showAlert(`Timer adjusted to ${formattedTime}`, 'success');
            } else {
                // Timer is not running - set initial offset
                manualTimeOffset = newOffset;
                document.getElementById('timerDisplay').textContent = formattedTime;
                document.getElementById('timerStatus').textContent = `Time set to ${formattedTime} - Ready to start`;
                showAlert(`Timer set to start from ${formattedTime}`, 'success');
            }
        }

        // Update summary table
        function updateSummary() {
            const container = document.getElementById('summaryContainer');
            
            if (timeEntries.length === 0) {
                container.innerHTML = `
                    <p style="text-align: center; color: #6c757d; padding: 20px;">
                        No time entries recorded yet. Start tracking your time!
                    </p>
                `;
                return;
            }

            const currentDay = getCurrentWeekday();
            const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];

            // Calculate daily totals
            let dayTotals = [0, 0, 0, 0, 0];

            // Group entries by project name
            const groupedEntries = {};
            timeEntries.forEach(entry => {
                const projName = entry.projectNameFilter || 'Uncategorized';
                if (!groupedEntries[projName]) {
                    groupedEntries[projName] = [];
                }
                groupedEntries[projName].push(entry);
            });

            let html = `
                <table class="timecard-table">
                    <thead>
                        <tr>
                            <th class="edit-column edit-column-header" title="Quick edit row">‚úèÔ∏è</th>
                            <th>Project Name</th>
                            <th>Project Number</th>
                            <th>Task</th>
                            ${days.map((day, i) => `<th class="day-column${i + 1 === currentDay ? ' current-day' : ''}"${i + 1 === currentDay ? ' style=\"background:#28a745;color:white;font-weight:bold;\"' : ''}>${day}</th>`).join('')}
                            <th class="day-column">Total</th>
                            <th style="text-align: center;">Action</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            // Process each project name group
            let rowId = 0;
            Object.keys(groupedEntries).sort().forEach(projName => {
                const entries = groupedEntries[projName];
                let projectDayTotals = [0, 0, 0, 0, 0];

                // Add entries for this project
                entries.forEach((entry, index) => {
                    let totalSeconds = 0;
                    // Get entry index before building HTML
                    const entryIndex = timeEntries.indexOf(entry);
                    
                    html += `<tr id="row-${entryIndex}">`;
                    
                    // Add edit column with pencil icon
                    html += `<td class="edit-column" onclick="toggleInlineEdit(${entryIndex})" title="Click to edit this row" style="cursor: pointer;">`;
                    html += `<span style="font-size: 1.2em;">‚úèÔ∏è</span>`;
                    html += `</td>`;
                    
                    // Show project name only on first row of each group
                    if (index === 0) {
                        const projectName = entry.projectNameFilter || 'Uncategorized';
                        html += `<td rowspan="${entries.length}" onclick="copyToClipboard('${projectName.replace(/'/g, "\\'")}', this)" style="cursor: pointer;" title="Click to copy">
                            <span>${projectName}</span>
                        </td>`;
                    }
                    
                    html += `<td onclick="copyToClipboard('${entry.project.replace(/'/g, "\\'")}', this)" style="cursor: pointer;" title="Click to copy">
                        <span>${entry.project}</span>
                    </td>`;
                    html += `<td onclick="copyToClipboard('${entry.task.replace(/'/g, "\\'")}', this)" style="cursor: pointer;" title="Click to copy">
                        <span>${entry.task}</span>
                    </td>`;
                    
                    for (let i = 1; i <= 5; i++) {
                        const timeStr = entry[`day${i}_hr`] || '00:00:00';
                        const seconds = parseHHMMSSToSeconds(timeStr);
                        const comment = entry[`day${i}_comment`] || '';
                        const clockTime = entry[`day${i}_clocktime`] || '';
                        totalSeconds += seconds;
                        dayTotals[i - 1] += seconds;
                        projectDayTotals[i - 1] += seconds;
                        // Only apply green to header, not cells
                        html += `<td class="day-column">`;
                        if (seconds > 0) {
                            html += `<div onclick="copyToClipboard('${timeStr}', this)" style="cursor: pointer;" title="Click to copy time">`;
                            html += `<span class="hours">${timeStr}</span>`;
                            html += `</div>`;
                            if (comment) {
                                html += `<div style="cursor: pointer; margin-top: 5px;" onclick="event.stopPropagation(); copyToClipboard('${comment.replace(/'/g, "\\'")}', this)" title="Click to copy comment">`;
                                html += `<span class="comment" data-comment-row="${rowId}">${comment}</span>`;
                                html += `</div>`;
                            }
                        } else {
                            html += `<div style="color: #6c757d; padding: 8px;">-</div>`;
                        }
                        html += `</td>`;
                    }
                    
                    const totalTime = formatSecondsToHHMMSS(totalSeconds);
                    const totalHours = convertToDecimalHours(totalTime);
                    html += `<td class="day-column total-row" onclick="copyToClipboard('${totalHours}', this)" style="cursor: pointer;" title="Click to copy total hours"><span class="hours">${totalHours} hrs</span></td>`;
                    
                    // Add action buttons
                    html += `<td style="text-align: center; white-space: nowrap;">`;
                    html += `<button class="action-btn" onclick="resumeEntry(${entryIndex})" title="Resume timing this task">`;
                    html += `‚ñ∂Ô∏è`;
                    html += `</button>`;
                    html += `<button class="action-btn" style="filter: hue-rotate(310deg) saturate(2);" onclick="deleteEntry(${entryIndex})" title="Delete this entry">`;
                    html += `üóëÔ∏è`;
                    html += `</button>`;
                    html += `<button class="action-btn" style="filter: hue-rotate(80deg) saturate(1.5);" onclick="toggleRowComments(${rowId}, this)" title="Show/hide comments">`;
                    html += `üí¨`;
                    html += `</button>`;
                    html += `</td>`;
                    
                    html += `</tr>`;
                    rowId++;
                });
            });

            // Add grand totals row
            html += `<tr style="background: var(--header-bg); font-weight: 600; border-top: 3px solid var(--header-bg);">`;
            html += `<td class="edit-column" style="background: var(--header-bg);"></td>`; // Empty edit column for grand total row
            html += `<td colspan="3" style="text-align: right; padding-right: 15px; color: var(--header-text); background: var(--header-bg); padding: 15px;">Grand Total:</td>`;
            
            let grandTotalSeconds = 0;
            for (let i = 0; i < 5; i++) {
                grandTotalSeconds += dayTotals[i];
                const dayTotal = formatSecondsToHHMMSS(dayTotals[i]);
                const dayHours = convertToDecimalHours(dayTotal);
                const isCurrentDayCell = i + 1 === currentDay;
                const bgColor = isCurrentDayCell ? '#28a745' : 'var(--header-bg)';
                html += `<td class="day-column ${isCurrentDayCell ? 'current-day' : ''}" style="text-align: center; background: ${bgColor}; color: var(--header-text); padding: 15px;">`;
                if (dayTotals[i] > 0) {
                    html += `<div class="hours" style="color: var(--header-text) !important;">${dayHours} hrs</div>`;
                } else {
                    html += '-';
                }
                html += `</td>`;
            }
            
            const grandTotal = formatSecondsToHHMMSS(grandTotalSeconds);
            const grandTotalHours = convertToDecimalHours(grandTotal);
            html += `<td class="day-column" style="text-align: center; background: var(--header-bg); color: var(--header-text); padding: 15px;">`;
            html += `<div class="hours" style="color: var(--header-text) !important;">${grandTotalHours} hrs</div>`;
            html += `<div style="font-size: 0.85em; margin-top: 5px; color: var(--header-text);">Total Week</div>`;
            html += `</td>`;
            html += `<td style="background: var(--header-bg);"></td>`; // Empty action cell for grand total row
            html += `</tr>`;

            html += `</tbody></table>`;
            container.innerHTML = html;
        }

        // Resume entry from summary table
        async function resumeEntry(entryIndex) {
            // Check if timer is currently running
            if (startTime !== null) {
                if (!confirm('A timer is already running. Do you want to stop it and start a new one?')) {
                    return;
                }
                stopTimer();
            }

            const entry = timeEntries[entryIndex];
            if (!entry) {
                showAlert('Entry not found!', 'error');
                return;
            }

            // Populate the form with the entry data
            document.getElementById('projectNameFilter').value = entry.projectNameFilter || '';
            document.getElementById('projectName').value = entry.project || '';
            document.getElementById('taskName').value = entry.task || '';
            
            // Prompt for comment before resuming
            const userComment = await promptForComment('', entry.projectNameFilter || '', entry.project || '', entry.task || '');
            if (userComment === null) {
                // User cancelled
                return;
            }
            document.getElementById('comment').value = userComment;

            // Update dropdowns to reflect the selection
            updateDropdowns();

            // Ensure we're on the current week so timer starts in current week
            if (weekOffset !== 0) {
                const weekMessage = weekOffset < 0 ? 'past week' : 'future week';
                showAlert(`Switching from ${weekMessage} to current week to resume timer...`, 'info');
                
                weekOffset = 0;
                loadData();
                loadWeekDates();
                updateSummary();
                updateWeekView();
            }

            // Ask user if they want to continue from where they stopped or start fresh
            const currentDay = getCurrentWeekday();
            const clockTimeKey = `day${currentDay}_clocktime`;
            const existingClockTime = entry[clockTimeKey] || '';
            
            let customStartTime = null;
            isContinuingLastBlock = false; // Reset flag
            
            if (existingClockTime) {
                // Get the last time block
                const blocks = existingClockTime.split(',').map(b => b.trim());
                const lastBlock = blocks[blocks.length - 1];
                const [lastStart, lastEnd] = lastBlock.split('-').map(s => s.trim());
                
                const resumeChoice = await showConfirmDialog(
                    `Do you want to continue from where you stopped?\n\n` +
                    `Last time block: ${lastBlock}\n\n` +
                    `Click "Continue" to continue from ${lastEnd}\n` +
                    `Click "Start New" to start a new time block from now`
                );
                
                if (resumeChoice) {
                    // Parse the last end time
                    const lastEndTime = parseClockTime(lastEnd);
                    if (lastEndTime) {
                        customStartTime = lastEndTime.getTime();
                        isContinuingLastBlock = true; // Set flag
                        showAlert(`Continuing from ${lastEnd}`, 'info');
                    }
                } else {
                    isContinuingLastBlock = false;
                }
            }

            // Scroll to timer section
            document.querySelector('.timer-section').scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Start the timer automatically
            setTimeout(() => {
                // If we have a custom start time, set it before starting
                if (customStartTime !== null) {
                    // Set startTime first before anything else
                    startTime = customStartTime;
                    manualTimeOffset = 0;
                    
                    // Set up timer UI
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('projectNameFilter').disabled = true;
                    document.getElementById('projectName').disabled = true;
                    document.getElementById('taskName').disabled = true;
                    document.getElementById('comment').disabled = true;
                    document.getElementById('timerStatus').textContent = 'Timer running (Click time to edit)';
                    
                    // Update displays immediately
                    updateTimerDisplay();
                    
                    // Update week view immediately since startTime is now set
                    updateWeekView();
                    
                    // Set up timer interval
                    timerInterval = setInterval(updateTimerDisplay, 1000);
                    
                    // Set up mini window if active
                    if (miniWindowActive) {
                        updateMiniWindowInfo();
                    }
                    
                    // Set up periodic week view refresh
                    if (!weekViewRefreshInterval) {
                        weekViewRefreshInterval = setInterval(() => {
                            if (startTime !== null) {
                                updateWeekView();
                            }
                        }, 5000);
                    }
                } else {
                    // Start timer normally from now
                    startTimer();
                }
            }, 500);
        }

        // Find an entry by keys and resume it (used by week-view time-block record buttons)
        function resumeEntryByKeys(projectName, task, startTime, endTime, dayIndex) {
            // Normalize inputs
            projectName = projectName || '';
            task = task || '';
            startTime = startTime || '';
            endTime = endTime || '';

            // Search through timeEntries to find a matching entry (exact match)
            for (let i = 0; i < timeEntries.length; i++) {
                const e = timeEntries[i];
                const eStart = e[`day${dayIndex}_clocktime`] ? (e[`day${dayIndex}_clocktime`].split(',').pop().trim()) : '';
                // eStart may be in format "HH:MM AM - HH:MM PM"; compare start/end strings too if provided
                if ((e.projectNameFilter || '') === projectName && (e.task || '') === task) {
                    // If we have exact start/end times in the block, prefer exact match
                    if (startTime && endTime) {
                        // Compare stored clocktimes for the day (contains ranges), try to match the last range
                        if (eStart && eStart.includes(startTime) && eStart.includes(endTime)) {
                            resumeEntry(i);
                            return true;
                        }
                    } else {
                        // No exact times provided ‚Äî resume on project/task/day match
                        if (e.dayIndex == dayIndex || typeof e.dayIndex === 'undefined') {
                            resumeEntry(i);
                            return true;
                        }
                    }
                }
            }

            // Fallback: match by project and task only
            for (let i = 0; i < timeEntries.length; i++) {
                const e = timeEntries[i];
                if ((e.projectNameFilter || '') === projectName && (e.task || '') === task) {
                    resumeEntry(i);
                    return true;
                }
            }

            alert('Could not find matching entry to resume.');
            return false;
        }

        // Resume last job (used by PiP window)
        function resumeLastJob() {
            // Check if timer is currently running
            if (startTime !== null) {
                showAlert('Timer is already running!', 'info');
                return;
            }

            // Ensure we're on the current week
            if (weekOffset !== 0) {
                weekOffset = 0;
                loadData();
                loadWeekDates();
                updateSummary();
                updateWeekView();
            }

            // Try to get last task info
            let projectNameFilter = '';
            let project = '';
            let task = '';

            // First try lastActiveTask (most recently stopped timer)
            if (lastActiveTask && lastActiveTask.projectNameFilter && lastActiveTask.project && lastActiveTask.task) {
                projectNameFilter = lastActiveTask.projectNameFilter;
                project = lastActiveTask.project;
                task = lastActiveTask.task;
            }
            // If no lastActiveTask, try to get the most recent entry from timeEntries
            else if (timeEntries.length > 0) {
                const lastEntry = timeEntries[timeEntries.length - 1];
                projectNameFilter = lastEntry.projectNameFilter || '';
                project = lastEntry.project || '';
                task = lastEntry.task || '';
            }

            // Populate the form with the entry data
            document.getElementById('projectNameFilter').value = projectNameFilter;
            document.getElementById('projectName').value = project;
            document.getElementById('taskName').value = task;
            document.getElementById('comment').value = '';

            // Update dropdowns to reflect the selection
            updateDropdowns();

            // Start the timer (it will use the populated values or show an error if empty)
            startTimer();
        }

        // Toggle timer from PiP window
        async function toggleTimerFromPip() {
            try {
                if (startTime !== null) {
                    // Timer is running - stop it
                    stopTimer();
                } else {
                    // Timer is not running - start it from PiP
                    await resumeLastJobFromPip();
                }
            } catch (error) {
                console.error('Error in toggleTimerFromPip:', error);
                alert('Error toggling timer: ' + error.message);
            }
        }

        // Resume last job from PiP window with prompts shown in PiP
        async function resumeLastJobFromPip() {
            // Get the PiP window reference
            const targetWindow = (pipWindow && !pipWindow.closed) ? pipWindow : window;
            
            // Check if timer is currently running
            if (startTime !== null) {
                alert('Timer is already running!');
                return;
            }

            // Ensure we're on the current week
            if (weekOffset !== 0) {
                weekOffset = 0;
                loadData();
                loadWeekDates();
                updateSummary();
                updateWeekView();
            }

            // Try to get last task info
            let projectNameFilter = '';
            let project = '';
            let task = '';
            let entryIndex = -1;

            // First try lastActiveTask (most recently stopped timer)
            if (lastActiveTask && lastActiveTask.projectNameFilter && lastActiveTask.project && lastActiveTask.task) {
                projectNameFilter = lastActiveTask.projectNameFilter;
                project = lastActiveTask.project;
                task = lastActiveTask.task;
                
                // Find the entry index for this task
                entryIndex = timeEntries.findIndex(e => 
                    e.projectNameFilter === projectNameFilter &&
                    e.project === project &&
                    e.task === task
                );
            }
            // If no lastActiveTask, try to get the most recent entry from timeEntries
            else if (timeEntries.length > 0) {
                entryIndex = timeEntries.length - 1;
                const lastEntry = timeEntries[entryIndex];
                projectNameFilter = lastEntry.projectNameFilter || '';
                project = lastEntry.project || '';
                task = lastEntry.task || '';
            }

            // Populate the form with the entry data
            document.getElementById('projectNameFilter').value = projectNameFilter;
            document.getElementById('projectName').value = project;
            document.getElementById('taskName').value = task;

            // Prompt for comment in PiP window
            const userComment = await promptForComment('', projectNameFilter, project, task, targetWindow);
            if (userComment === null) {
                // User cancelled
                return;
            }
            document.getElementById('comment').value = userComment;

            // Update dropdowns to reflect the selection
            updateDropdowns();

            // Check if we should ask about continuing from last block
            const currentDay = getCurrentWeekday();
            let customStartTime = null;
            isContinuingLastBlock = false;

            if (entryIndex >= 0) {
                const entry = timeEntries[entryIndex];
                const clockTimeKey = `day${currentDay}_clocktime`;
                const existingClockTime = entry[clockTimeKey] || '';
                
                if (existingClockTime) {
                    // Get the last time block
                    const blocks = existingClockTime.split(',').map(b => b.trim());
                    const lastBlock = blocks[blocks.length - 1];
                    const [lastStart, lastEnd] = lastBlock.split('-').map(s => s.trim());
                    
                    const resumeChoice = await showConfirmDialog(
                        `Do you want to continue from where you stopped?\n\n` +
                        `Last time block: ${lastBlock}\n\n` +
                        `Click "Continue" to continue from ${lastEnd}\n` +
                        `Click "Start New" to start a new time block from now`,
                        targetWindow
                    );
                    
                    if (resumeChoice) {
                        // Parse the last end time
                        const lastEndTime = parseClockTime(lastEnd);
                        if (lastEndTime) {
                            customStartTime = lastEndTime.getTime();
                            isContinuingLastBlock = true;
                        }
                    } else {
                        isContinuingLastBlock = false;
                    }
                }
            }

            // Start the timer
            // Set startTime (either custom or current time)
            startTime = customStartTime !== null ? customStartTime : Date.now();
            manualTimeOffset = 0;
            
            // Set up timer UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('projectNameFilter').disabled = true;
            document.getElementById('projectName').disabled = true;
            document.getElementById('taskName').disabled = true;
            document.getElementById('comment').disabled = true;
            document.getElementById('timerStatus').textContent = 'Timer running (Click time to edit)';
            
            // Update displays immediately
            updateTimerDisplay();
            
            // Update week view immediately since startTime is now set
            updateWeekView();
            
            // Set up timer interval
            timerInterval = setInterval(updateTimerDisplay, 1000);
            
            // Set up mini window if active
            if (miniWindowActive) {
                updateMiniWindowInfo();
            }
            
            // Set up periodic week view refresh
            if (!weekViewRefreshInterval) {
                weekViewRefreshInterval = setInterval(() => {
                    if (startTime !== null) {
                        updateWeekView();
                    }
                }, 5000);
            }
        }

        // Edit individual field (projectNameFilter, project, or task)
        // Opens a modal dialog populated with history datalists (similar to week view)
        function editField(entryIndex, fieldName) {
            const entry = timeEntries[entryIndex];
            if (!entry) {
                showAlert('Entry not found!', 'error');
                return;
            }

            // Build datalist options from history
            let projectNameOptions = '';
            let projectNumberOptions = '';
            let taskOptions = '';

            projectNameHistory.forEach(item => { projectNameOptions += `<option value="${item}">`; });
            projectHistory.forEach(item => { projectNumberOptions += `<option value="${item}">`; });
            taskHistory.forEach(item => { taskOptions += `<option value="${item}">`; });

            const fieldLabels = {
                'projectNameFilter': 'Project Name',
                'project': 'Project Number',
                'task': 'Task Name'
            };

            const label = fieldLabels[fieldName] || fieldName;

            // Create modal dialog HTML (allows editing all three fields but focuses on requested one)
            const dialogHTML = `
                <div id="tableEditDialog" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 9999; display: flex; align-items: center; justify-content: center;" onclick="if(event.target.id === 'tableEditDialog') document.getElementById('tableEditDialog').remove();">
                    <div style="background: white; border-radius: 8px; padding: 20px; max-width: 520px; width: 92%; box-shadow: 0 4px 20px rgba(0,0,0,0.3);" onclick="event.stopPropagation();">
                        <h3 style="margin-top: 0; color: #333;">Edit Entry - ${label}</h3>
                        <div style="margin-bottom: 12px;">
                            <label style="display:block; font-weight:600; margin-bottom:6px; color:#555;">Project Name:</label>
                            <input type="text" id="tableEditProjectName" value="${(entry.projectNameFilter||'').replace(/"/g,'&quot;')}" list="tableEditProjectNameList" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px; font-size:14px;">
                            <datalist id="tableEditProjectNameList">${projectNameOptions}</datalist>
                        </div>
                        <div style="margin-bottom:12px;">
                            <label style="display:block; font-weight:600; margin-bottom:6px; color:#555;">Project Number:</label>
                            <input type="text" id="tableEditProjectNumber" value="${(entry.project||'').replace(/"/g,'&quot;')}" list="tableEditProjectNumberList" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px; font-size:14px;">
                            <datalist id="tableEditProjectNumberList">${projectNumberOptions}</datalist>
                        </div>
                        <div style="margin-bottom:16px;">
                            <label style="display:block; font-weight:600; margin-bottom:6px; color:#555;">Task Name:</label>
                            <input type="text" id="tableEditTask" value="${(entry.task||'').replace(/"/g,'&quot;')}" list="tableEditTaskList" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px; font-size:14px;">
                            <datalist id="tableEditTaskList">${taskOptions}</datalist>
                        </div>
                        <div style="display:flex; gap:10px; justify-content:space-between; align-items:center;">
                            <button onclick="openHistoryEditor()" style="padding:8px 12px; background:#17a2b8; color:white; border:none; border-radius:4px; cursor:pointer; font-size:14px; font-weight:600;">History</button>
                            <div style="display:flex; gap:10px; justify-content:flex-end;">
                                <button onclick="document.getElementById('tableEditDialog').remove()" style="padding:8px 14px; background:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer; font-size:14px;">Cancel</button>
                                <button onclick="saveTableFieldEdit(${entryIndex}, '${fieldName}')" style="padding:8px 14px; background:#366092; color:white; border:none; border-radius:4px; cursor:pointer; font-size:14px; font-weight:600;">Save</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', dialogHTML);
            // After dialog is added, wire input listener to filter project numbers and tasks
            setTimeout(() => {
                const projInput = document.getElementById('editProjectName');
                const projNumberList = document.getElementById('editProjectNumberList');
                const taskList = document.getElementById('editTaskList');

                function updateEditLists() {
                    const selectedProjectName = projInput.value.trim();
                    let projects = [];
                    let tasks = [];

                    if (selectedProjectName && structuredHistory[selectedProjectName]) {
                        const projSet = structuredHistory[selectedProjectName].projects;
                        const taskSet = structuredHistory[selectedProjectName].tasks;
                        projects = Array.from(projSet instanceof Set ? projSet : new Set(projSet)).sort();
                        tasks = Array.from(taskSet instanceof Set ? taskSet : new Set(taskSet)).sort();
                    } else {
                        projects = Array.from(projectHistory).sort();
                        tasks = Array.from(taskHistory).sort();
                    }

                    projNumberList.innerHTML = '';
                    projects.forEach(p => projNumberList.insertAdjacentHTML('beforeend', `<option value="${p}">`));

                    taskList.innerHTML = '';
                    tasks.forEach(t => taskList.insertAdjacentHTML('beforeend', `<option value="${t}">`));
                }

                projInput.addEventListener('input', () => {
                    document.getElementById('editProjectNumber').value = '';
                    document.getElementById('editTask').value = '';
                    updateEditLists();
                });

                // initialize lists based on current project name
                updateEditLists();

                // focus project name for convenience
                if (projInput) projInput.focus();
            }, 50);

            // After dialog is added, wire input listener to filter project numbers and tasks
            setTimeout(() => {
                const projInput = document.getElementById('tableEditProjectName');
                const projNumberList = document.getElementById('tableEditProjectNumberList');
                const taskList = document.getElementById('tableEditTaskList');

                function updateTableEditLists() {
                    const selectedProjectName = projInput.value.trim();
                    let projects = [];
                    let tasks = [];

                    if (selectedProjectName && structuredHistory[selectedProjectName]) {
                        const projSet = structuredHistory[selectedProjectName].projects;
                        const taskSet = structuredHistory[selectedProjectName].tasks;
                        projects = Array.from(projSet instanceof Set ? projSet : new Set(projSet)).sort();
                        tasks = Array.from(taskSet instanceof Set ? taskSet : new Set(taskSet)).sort();
                    } else {
                        projects = Array.from(projectHistory).sort();
                        tasks = Array.from(taskHistory).sort();
                    }

                    projNumberList.innerHTML = '';
                    projects.forEach(p => projNumberList.insertAdjacentHTML('beforeend', `<option value="${p}">`));

                    taskList.innerHTML = '';
                    tasks.forEach(t => taskList.insertAdjacentHTML('beforeend', `<option value="${t}">`));
                }

                projInput.addEventListener('input', () => {
                    // clear dependent fields when project name changes
                    document.getElementById('tableEditProjectNumber').value = '';
                    document.getElementById('tableEditTask').value = '';
                    updateTableEditLists();
                });

                // initialize lists
                updateTableEditLists();

                // Focus the specific input for convenience
                if (fieldName === 'projectNameFilter') document.getElementById('tableEditProjectName').focus();
                else if (fieldName === 'project') document.getElementById('tableEditProjectNumber').focus();
                else document.getElementById('tableEditTask').focus();
            }, 50);
        }

        // Save the table edit modal changes
        function saveTableFieldEdit(entryIndex, fieldName) {
            const entry = timeEntries[entryIndex];
            if (!entry) {
                showAlert('Entry not found!', 'error');
                return;
            }

            const newProjectName = document.getElementById('tableEditProjectName').value.trim();
            const newProjectNumber = document.getElementById('tableEditProjectNumber').value.trim();
            const newTask = document.getElementById('tableEditTask').value.trim();

            if (!newProjectName || !newProjectNumber || !newTask) {
                showAlert('Project Name, Project Number, and Task Name are required!', 'error');
                return;
            }

            // Update history sets
            projectNameHistory.add(newProjectName);
            projectHistory.add(newProjectNumber);
            taskHistory.add(newTask);

            // Update structured history for project name
            if (!structuredHistory[newProjectName]) {
                structuredHistory[newProjectName] = { projects: new Set(), tasks: new Set(), comments: new Set() };
            }
            structuredHistory[newProjectName].projects.add(newProjectNumber);
            structuredHistory[newProjectName].tasks.add(newTask);

            // Apply changes to entry
            const oldProjectName = entry.projectNameFilter || '';
            const oldProjectNumber = entry.project || '';
            const oldTask = entry.task || '';

            entry.projectNameFilter = newProjectName;
            entry.project = newProjectNumber;
            entry.task = newTask;

            saveHistory();
            saveData();
            updateSummary();
            updateDropdowns();

            // Remove dialog
            const dlg = document.getElementById('tableEditDialog');
            if (dlg) dlg.remove();

            showAlert('Entry updated successfully!', 'success');
        }

        // Edit entry from summary table (all fields at once)
        // Opens the modal-based editor and focuses Project Name first so subsequent fields
        // (Project Number, Task) are filtered by the selected project.
        function editEntry(entryIndex) {
            const entry = timeEntries[entryIndex];
            if (!entry) {
                showAlert('Entry not found!', 'error');
                return;
            }

            // Reuse the table edit modal which prompts for Project Name first
            editField(entryIndex, 'projectNameFilter');
        }

        // Delete entry from summary table
        function deleteEntry(entryIndex) {
            const entry = timeEntries[entryIndex];
            if (!entry) {
                showAlert('Entry not found!', 'error');
                return;
            }

            const confirmMsg = `WARNING: This will permanently delete this entry!\n\nProject: ${entry.projectNameFilter || 'N/A'}\nProject Number: ${entry.project}\nTask: ${entry.task}\n\nType "Delete" to confirm:`;
            
            const userInput = prompt(confirmMsg, '');
            
            if (userInput === 'Delete') {
                timeEntries.splice(entryIndex, 1);
                saveData();
                    updateSummary();
                    updateWeekView();
                showAlert('Entry deleted successfully!', 'success');
            } else if (userInput !== null) {
                showAlert('Delete cancelled - you must type "Delete" exactly to confirm', 'error');
            }
        }

        // Copy text to clipboard (for table cell clicks)
        function copyToClipboard(text, cellElement) {
            // Don't copy if we're in edit mode
            const row = cellElement.closest('tr');
            if (row && row.classList.contains('edit-mode-active')) {
                return;
            }

            // Copy to clipboard using modern API with fallback
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showCopyFeedback(cellElement);
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    fallbackCopyToClipboard(text, cellElement);
                });
            } else {
                fallbackCopyToClipboard(text, cellElement);
            }
        }

        // Fallback copy method for older browsers
        function fallbackCopyToClipboard(text, cellElement) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showCopyFeedback(cellElement);
            } catch (err) {
                console.error('Failed to copy:', err);
            }
            document.body.removeChild(textarea);
        }

        // Show visual feedback when content is copied
        function showCopyFeedback(element) {
            const originalBg = element.style.backgroundColor;
            element.style.backgroundColor = '#4CAF50';
            element.style.transition = 'background-color 0.3s';
            
            setTimeout(() => {
                element.style.backgroundColor = originalBg;
                setTimeout(() => {
                    element.style.transition = '';
                }, 300);
            }, 200);
        }

        // Add a new time block for editing (only updates UI, not saved until user clicks save)
        function addTimeBlock(entryIndex, dayNum) {
            // Prompt for start and end time
            const startTime = prompt('Enter start time (e.g., 09:00 AM):', '');
            if (!startTime) return;
            
            const endTime = prompt('Enter end time (e.g., 05:00 PM):', '');
            if (!endTime) return;
            
            // Validate that end time is after start time
            const start = parseClockTime(startTime);
            const end = parseClockTime(endTime);
            
            if (!start || !end) {
                showAlert('Invalid time format! Use formats like "9:00 AM" or "17:00"', 'error');
                return;
            }
            
            if (end <= start) {
                showAlert('End time must be after start time!', 'error');
                return;
            }
            
            // Temporarily store the new block in the row's dataset
            const row = document.getElementById(`row-${entryIndex}`);
            if (!row) return;
            
            // Get or initialize temp storage for new blocks
            let tempNewBlocks = row.dataset.tempNewBlocks ? JSON.parse(row.dataset.tempNewBlocks) : {};
            if (!tempNewBlocks[dayNum]) {
                tempNewBlocks[dayNum] = [];
            }
            
            // Add the new block
            tempNewBlocks[dayNum].push(`${startTime} - ${endTime}`);
            row.dataset.tempNewBlocks = JSON.stringify(tempNewBlocks);
            
            // Refresh the inline edit view to show the new block
            row.classList.remove('edit-mode-active');
            toggleInlineEdit(entryIndex);
        }

        // Remove a time block (only updates UI, not saved until user clicks save)
        function removeTimeBlock(entryIndex, dayNum, blockIndex) {
            // Temporarily store the removed block index in the row's dataset
            const row = document.getElementById(`row-${entryIndex}`);
            if (!row) return;
            
            // Get or initialize temp storage for removed blocks
            let tempRemovedBlocks = row.dataset.tempRemovedBlocks ? JSON.parse(row.dataset.tempRemovedBlocks) : {};
            if (!tempRemovedBlocks[dayNum]) {
                tempRemovedBlocks[dayNum] = [];
            }
            
            // Add this block index to the removed list
            tempRemovedBlocks[dayNum].push(blockIndex);
            row.dataset.tempRemovedBlocks = JSON.stringify(tempRemovedBlocks);
            
            // Refresh the inline edit view to hide the removed block
            row.classList.remove('edit-mode-active');
            toggleInlineEdit(entryIndex);
        }

        // Recalculate total time from time blocks
        function recalculateTimeFromBlocks(entryIndex, dayNum) {
            const entry = timeEntries[entryIndex];
            if (!entry) return;
            
            const clockTimeKey = `day${dayNum}_clocktime`;
            const clockTime = entry[clockTimeKey] || '';
            
            if (!clockTime) {
                entry[`day${dayNum}_hr`] = '00:00:00';
                return;
            }
            
            let totalSeconds = 0;
            const blocks = clockTime.split(',').map(b => b.trim());
            
            blocks.forEach(block => {
                const [startStr, endStr] = block.split('-').map(s => s.trim());
                if (startStr && endStr) {
                    const start = parseClockTime(startStr);
                    const end = parseClockTime(endStr);
                    if (start && end) {
                        const diff = end - start;
                        if (diff > 0) {
                            totalSeconds += Math.floor(diff / 1000);
                        }
                    }
                }
            });
            
            entry[`day${dayNum}_hr`] = formatSecondsToHHMMSS(totalSeconds);
        }

        // Parse clock time string to Date object
        function parseClockTime(timeStr) {
            try {
                // Handle formats like "09:00 AM" or "9:00 AM" or "17:00"
                const match = timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
                if (!match) return null;
                
                let hours = parseInt(match[1]);
                const minutes = parseInt(match[2]);
                const meridiem = match[3] ? match[3].toUpperCase() : null;
                
                if (meridiem === 'PM' && hours !== 12) {
                    hours += 12;
                } else if (meridiem === 'AM' && hours === 12) {
                    hours = 0;
                }
                
                const date = new Date();
                date.setHours(hours, minutes, 0, 0);
                return date;
            } catch (e) {
                return null;
            }
        }

        // Toggle inline edit mode for a table row
        function toggleInlineEdit(entryIndex) {
            const entry = timeEntries[entryIndex];
            if (!entry) {
                showAlert('Entry not found!', 'error');
                return;
            }

            const row = document.getElementById(`row-${entryIndex}`);
            if (!row) return;

            // Check if already in edit mode
            if (row.classList.contains('edit-mode-active')) {
                cancelInlineEdit(entryIndex);
                return;
            }

            // Close any other row in edit mode
            document.querySelectorAll('.edit-mode-active').forEach(r => {
                const idx = r.id.replace('row-', '');
                cancelInlineEdit(parseInt(idx));
            });

            // Enable edit mode
            row.classList.add('edit-mode-active');

            // Find the cells (skip edit column)
            const cells = row.querySelectorAll('td');
            
            // Determine which cell indices to edit (accounting for potential rowspan)
            let projNameCell, projNumCell, taskCell, dayCells;
            let cellOffset = 0;
            
            // Check if this row has the project name cell (not rowspanned)
            const firstContentCell = cells[1]; // After edit column
            if (firstContentCell.hasAttribute('rowspan')) {
                projNameCell = firstContentCell;
                projNumCell = cells[2];
                taskCell = cells[3];
                cellOffset = 4; // edit + projName + projNum + task
            } else {
                // This row doesn't have project name (it's part of a rowspan group)
                projNumCell = cells[1];
                taskCell = cells[2];
                cellOffset = 3; // edit + projNum + task
            }
            
            // Get the 5 day columns (Mon-Fri)
            dayCells = [
                cells[cellOffset],     // Mon
                cells[cellOffset + 1], // Tue
                cells[cellOffset + 2], // Wed
                cells[cellOffset + 3], // Thu
                cells[cellOffset + 4]  // Fri
            ];

            // Store original values
            const origProjectName = entry.projectNameFilter || '';
            const origProjectNumber = entry.project || '';
            const origTask = entry.task || '';
            const origDayTimes = [
                entry.day1_hr || '00:00:00',
                entry.day2_hr || '00:00:00',
                entry.day3_hr || '00:00:00',
                entry.day4_hr || '00:00:00',
                entry.day5_hr || '00:00:00'
            ];

            // Build datalist options from history
            const projectNameOptions = Array.from(projectNameHistory).sort().map(item => `<option value="${item}">`).join('');
            
            // Build filtered project numbers and tasks based on current project name
            let projectNumbers = [];
            let tasks = [];
            
            if (origProjectName && structuredHistory[origProjectName]) {
                const projSet = structuredHistory[origProjectName].projects;
                const taskSet = structuredHistory[origProjectName].tasks;
                projectNumbers = Array.from(projSet instanceof Set ? projSet : new Set(projSet)).sort();
                tasks = Array.from(taskSet instanceof Set ? taskSet : new Set(taskSet)).sort();
                
                console.log('Filtered dropdowns for:', origProjectName);
                console.log('Project numbers:', projectNumbers);
                console.log('Tasks:', tasks);
            } else {
                console.log('No structured history found for:', origProjectName);
                console.log('Using all history - projects:', Array.from(projectHistory));
                console.log('Using all history - tasks:', Array.from(taskHistory));
                
                projectNumbers = Array.from(projectHistory).sort();
                tasks = Array.from(taskHistory).sort();
            }

            // Replace project name cell with input + datalist (if present)
            if (projNameCell && projNameCell.hasAttribute('rowspan')) {
                const projectNameList = Array.from(projectNameHistory).sort();
                let projectNameDatalistOptions = projectNameList.map(p => 
                    `<option value="${p.replace(/"/g, '&quot;')}">`
                ).join('');
                
                const projectNameHTML = `
                    <div class="input-with-clear">
                        <input type="text" 
                               class="inline-edit-input" 
                               id="inline-proj-name-input-${entryIndex}"
                               value="${origProjectName.replace(/"/g, '&quot;')}"
                               list="inline-proj-name-list-${entryIndex}"
                               placeholder="Type or select from dropdown"
                               style="width: 100%; padding-right: 32px;"
                               autocomplete="off">
                        <button type="button" class="input-clear-btn" onclick="event.stopPropagation(); document.getElementById('inline-proj-name-input-${entryIndex}').value=''; document.getElementById('inline-proj-name-input-${entryIndex}').focus();" title="Clear field">‚úï</button>
                        <datalist id="inline-proj-name-list-${entryIndex}">
                            ${projectNameDatalistOptions}
                        </datalist>
                    </div>
                `;
                projNameCell.innerHTML = projectNameHTML;
                projNameCell.style.cursor = 'default';
                
                // Add listener to filter project numbers and tasks when value changes
                setTimeout(() => {
                    const projNameInput = document.getElementById(`inline-proj-name-input-${entryIndex}`);
                    if (projNameInput) {
                        projNameInput.addEventListener('change', function() {
                            updateInlineEditLists(entryIndex);
                        });
                        projNameInput.addEventListener('input', function() {
                            updateInlineEditLists(entryIndex);
                        });
                        // Show all options on click by temporarily clearing and restoring value
                        projNameInput.addEventListener('click', function() {
                            const currentValue = this.value;
                            this.value = '';
                            this.focus();
                            setTimeout(() => {
                                if (!this.value) {
                                    this.value = currentValue;
                                }
                            }, 10);
                        });
                        // Also show on focus
                        projNameInput.addEventListener('focus', function() {
                            this.select();
                        });
                    }
                }, 50);
            }

            // Replace project number cell with input + datalist
            let projectNumberDatalistOptions = projectNumbers.map(p => 
                `<option value="${p.replace(/"/g, '&quot;')}">`
            ).join('');
            
            const projectNumberHTML = `
                <div class="input-with-clear">
                    <input type="text" 
                           class="inline-edit-input" 
                           id="inline-proj-num-input-${entryIndex}"
                           value="${origProjectNumber.replace(/"/g, '&quot;')}"
                           list="inline-proj-num-list-${entryIndex}"
                           placeholder="Type or select from dropdown"
                           style="width: 100%; padding-right: 32px;"
                           autocomplete="off">
                    <button type="button" class="input-clear-btn" onclick="event.stopPropagation(); document.getElementById('inline-proj-num-input-${entryIndex}').value=''; document.getElementById('inline-proj-num-input-${entryIndex}').focus();" title="Clear field">‚úï</button>
                    <datalist id="inline-proj-num-list-${entryIndex}">
                        ${projectNumberDatalistOptions}
                    </datalist>
                </div>
            `;
            projNumCell.innerHTML = projectNumberHTML;
            projNumCell.style.cursor = 'default';
            
            // Show all options on click
            setTimeout(() => {
                const projNumInput = document.getElementById(`inline-proj-num-input-${entryIndex}`);
                if (projNumInput) {
                    projNumInput.addEventListener('click', function() {
                        const currentValue = this.value;
                        this.value = '';
                        this.focus();
                        setTimeout(() => {
                            if (!this.value) {
                                this.value = currentValue;
                            }
                        }, 10);
                    });
                    projNumInput.addEventListener('focus', function() {
                        this.select();
                    });
                }
            }, 50);

            // Replace task cell with input + datalist
            let taskDatalistOptions = tasks.map(t => 
                `<option value="${t.replace(/"/g, '&quot;')}">`
            ).join('');
            
            const taskHTML = `
                <div class="input-with-clear">
                    <input type="text" 
                           class="inline-edit-input" 
                           id="inline-task-input-${entryIndex}"
                           value="${origTask.replace(/"/g, '&quot;')}"
                           list="inline-task-list-${entryIndex}"
                           placeholder="Type or select from dropdown"
                           style="width: 100%; padding-right: 32px;"
                           autocomplete="off">
                    <button type="button" class="input-clear-btn" onclick="event.stopPropagation(); document.getElementById('inline-task-input-${entryIndex}').value=''; document.getElementById('inline-task-input-${entryIndex}').focus();" title="Clear field">‚úï</button>
                    <datalist id="inline-task-list-${entryIndex}">
                        ${taskDatalistOptions}
                    </datalist>
                </div>
            `;
            taskCell.innerHTML = taskHTML;
            taskCell.style.cursor = 'default';
            
            // Show all options on click
            setTimeout(() => {
                const taskInput = document.getElementById(`inline-task-input-${entryIndex}`);
                if (taskInput) {
                    taskInput.addEventListener('click', function() {
                        const currentValue = this.value;
                        this.value = '';
                        this.focus();
                        setTimeout(() => {
                            if (!this.value) {
                                this.value = currentValue;
                            }
                        }, 10);
                    });
                    taskInput.addEventListener('focus', function() {
                        this.select();
                    });
                }
            }, 50);

            // Replace day cells with time inputs AND show time blocks
            for (let i = 0; i < 5; i++) {
                const dayCell = dayCells[i];
                const dayNum = i + 1;
                const timeValue = origDayTimes[i];
                let clockTime = entry[`day${dayNum}_clocktime`] || '';
                const comment = entry[`day${dayNum}_comment`] || '';
                
                // Get temporary additions and removals
                const tempNewBlocks = row.dataset.tempNewBlocks ? JSON.parse(row.dataset.tempNewBlocks) : {};
                const tempRemovedBlocks = row.dataset.tempRemovedBlocks ? JSON.parse(row.dataset.tempRemovedBlocks) : {};
                
                // Parse existing time blocks
                let clockRanges = clockTime ? clockTime.split(',').map(range => range.trim()) : [];
                
                // Remove blocks marked for deletion (in reverse order to maintain indices)
                if (tempRemovedBlocks[dayNum]) {
                    const removedIndices = tempRemovedBlocks[dayNum].sort((a, b) => b - a);
                    removedIndices.forEach(idx => {
                        if (idx < clockRanges.length) {
                            clockRanges.splice(idx, 1);
                        }
                    });
                }
                
                // Add new blocks
                if (tempNewBlocks[dayNum]) {
                    clockRanges = clockRanges.concat(tempNewBlocks[dayNum]);
                }
                
                // Calculate total time from current blocks (including temp changes)
                let totalSeconds = 0;
                clockRanges.forEach(range => {
                    const [startStr, endStr] = range.split('-').map(s => s.trim());
                    if (startStr && endStr) {
                        const start = parseClockTime(startStr);
                        const end = parseClockTime(endStr);
                        if (start && end) {
                            const diff = end - start;
                            if (diff > 0) {
                                totalSeconds += Math.floor(diff / 1000);
                            }
                        }
                    }
                });
                const calculatedTime = formatSecondsToHHMMSS(totalSeconds);
                
                // Parse time blocks for this day
                let timeBlocksHTML = '';
                if (clockRanges.length > 0) {
                    timeBlocksHTML = '<div style="margin-top: 8px; font-size: 0.85em;">';
                    clockRanges.forEach((range, blockIndex) => {
                        const [startStr, endStr] = range.split('-').map(s => s.trim());
                        if (startStr && endStr) {
                            timeBlocksHTML += `
                                <div style="display: flex; gap: 4px; align-items: center; margin-bottom: 4px; padding: 4px; background: #f0f0f0; border-radius: 4px;">
                                    <input type="text" 
                                           id="inline-day${dayNum}-block${blockIndex}-start-${entryIndex}"
                                           value="${startStr}"
                                           placeholder="Start"
                                           style="width: 70px; padding: 2px 4px; font-size: 0.9em; text-align: center;"
                                           title="Block ${blockIndex + 1} start time">
                                    <span style="color: #666;">-</span>
                                    <input type="text" 
                                           id="inline-day${dayNum}-block${blockIndex}-end-${entryIndex}"
                                           value="${endStr}"
                                           placeholder="End"
                                           style="width: 70px; padding: 2px 4px; font-size: 0.9em; text-align: center;"
                                           title="Block ${blockIndex + 1} end time">
                                    <button onclick="removeTimeBlock(${entryIndex}, ${dayNum}, ${blockIndex}); event.stopPropagation();"
                                            style="padding: 2px 6px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 0.8em;"
                                            title="Remove this time block">‚úï</button>
                                </div>
                            `;
                        }
                    });
                    timeBlocksHTML += '</div>';
                }
                
                const timeInputHTML = `
                    <div>
                        <input type="text" 
                               class="inline-edit-input" 
                               id="inline-day${dayNum}-time-${entryIndex}" 
                               value="${calculatedTime}"
                               placeholder="HH:MM:SS"
                               pattern="[0-9]{1,2}:[0-9]{2}:[0-9]{2}"
                               style="width: 100%; text-align: center;"
                               readonly
                               title="Total time for this day (calculated from blocks)">
                        <button onclick="addTimeBlock(${entryIndex}, ${dayNum}); event.stopPropagation();"
                                style="width: 100%; margin-top: 4px; padding: 4px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 0.85em;"
                                title="Add new time block for this day">+ Add Block</button>
                        ${timeBlocksHTML}
                    </div>
                `;
                dayCell.innerHTML = timeInputHTML;
                dayCell.style.cursor = 'default';
            }

            // Add save/cancel buttons to the edit column
            const editCell = cells[0];
            editCell.innerHTML = `
                <div class="inline-edit-actions">
                    <button class="inline-edit-btn save" onclick="event.stopPropagation(); saveInlineEdit(${entryIndex});" title="Save changes">‚úì</button>
                    <button class="inline-edit-btn cancel" onclick="event.stopPropagation(); cancelInlineEdit(${entryIndex});" title="Cancel">‚úï</button>
                </div>
            `;
            editCell.onclick = null;

            // Store original values for cancel
            row.dataset.origProjectName = origProjectName;
            row.dataset.origProjectNumber = origProjectNumber;
            row.dataset.origTask = origTask;
            row.dataset.origDayTimes = JSON.stringify(origDayTimes);

            // Add keyboard handlers for inline edit mode
            const keyboardHandler = function(event) {
                // Escape to cancel
                if (event.key === 'Escape') {
                    event.preventDefault();
                    cancelInlineEdit(entryIndex);
                }
                // Enter to save (with Ctrl/Cmd for compatibility)
                else if (event.key === 'Enter' && (event.ctrlKey || event.metaKey)) {
                    event.preventDefault();
                    saveInlineEdit(entryIndex);
                }
            };
            document.addEventListener('keydown', keyboardHandler);
            
            // Store handler reference for cleanup when switching rows
            if (!window.inlineEditHandlers) {
                window.inlineEditHandlers = {};
            }
            window.inlineEditHandlers[entryIndex] = keyboardHandler;

            // Focus the first input
            setTimeout(() => {
                if (projNameCell && projNameCell.hasAttribute('rowspan')) {
                    const input = document.getElementById(`inline-proj-name-input-${entryIndex}`);
                    if (input) input.focus();
                } else {
                    const input = document.getElementById(`inline-proj-num-input-${entryIndex}`);
                    if (input) input.focus();
                }
            }, 100);
        }

        // Update inline edit datalists based on selected project name
        function updateInlineEditLists(entryIndex) {
            const projNameInput = document.getElementById(`inline-proj-name-input-${entryIndex}`);
            if (!projNameInput) return;

            const selectedProjectName = projNameInput.value.trim();
            const projNumDatalist = document.getElementById(`inline-proj-num-list-${entryIndex}`);
            const taskDatalist = document.getElementById(`inline-task-list-${entryIndex}`);

            let projects = [];
            let tasks = [];

            if (selectedProjectName && structuredHistory[selectedProjectName]) {
                const projSet = structuredHistory[selectedProjectName].projects;
                const taskSet = structuredHistory[selectedProjectName].tasks;
                projects = Array.from(projSet instanceof Set ? projSet : new Set(projSet)).sort();
                tasks = Array.from(taskSet instanceof Set ? taskSet : new Set(taskSet)).sort();
            } else {
                projects = Array.from(projectHistory).sort();
                tasks = Array.from(taskHistory).sort();
            }

            // Update project number datalist
            if (projNumDatalist) {
                const projectNumberDatalistOptions = projects.map(p => 
                    `<option value="${p.replace(/"/g, '&quot;')}">`
                ).join('');
                projNumDatalist.innerHTML = projectNumberDatalistOptions;
            }

            // Update task datalist
            if (taskDatalist) {
                const taskDatalistOptions = tasks.map(t => 
                    `<option value="${t.replace(/"/g, '&quot;')}">`
                ).join('');
                taskDatalist.innerHTML = taskDatalistOptions;
            }
        }

        // Save inline edit changes
        function saveInlineEdit(entryIndex) {
            const entry = timeEntries[entryIndex];
            if (!entry) {
                showAlert('Entry not found!', 'error');
                return;
            }

            const row = document.getElementById(`row-${entryIndex}`);
            const projNameInput = document.getElementById(`inline-proj-name-input-${entryIndex}`);
            const projNumInput = document.getElementById(`inline-proj-num-input-${entryIndex}`);
            const taskInput = document.getElementById(`inline-task-input-${entryIndex}`);

            // Get new values (from text inputs)
            const newProjectName = projNameInput ? projNameInput.value.trim() : entry.projectNameFilter;
            const newProjectNumber = projNumInput ? projNumInput.value.trim() : entry.project;
            const newTask = taskInput ? taskInput.value.trim() : entry.task;
            
            // Get temporary time block changes
            const tempNewBlocks = row && row.dataset.tempNewBlocks ? JSON.parse(row.dataset.tempNewBlocks) : {};
            const tempRemovedBlocks = row && row.dataset.tempRemovedBlocks ? JSON.parse(row.dataset.tempRemovedBlocks) : {};
            
            // Process time blocks for each day and recalculate totals
            const newDayTimes = [];
            const newClockTimes = [];
            
            for (let i = 1; i <= 5; i++) {
                const dayNum = i;
                const clockTimeKey = `day${dayNum}_clocktime`;
                const clockTime = entry[clockTimeKey] || '';
                
                // Start with existing blocks
                let clockRanges = [];
                if (clockTime) {
                    clockRanges = clockTime.split(',').map(b => b.trim());
                }
                
                // Apply removals from temporary state
                if (tempRemovedBlocks[dayNum] && Array.isArray(tempRemovedBlocks[dayNum])) {
                    const indicesToRemove = [...tempRemovedBlocks[dayNum]].sort((a, b) => b - a);
                    indicesToRemove.forEach(idx => {
                        if (idx >= 0 && idx < clockRanges.length) {
                            clockRanges.splice(idx, 1);
                        }
                    });
                }
                
                // Collect edited time blocks (from UI inputs)
                const updatedBlocks = [];
                clockRanges.forEach((block, blockIndex) => {
                    const startInput = document.getElementById(`inline-day${dayNum}-block${blockIndex}-start-${entryIndex}`);
                    const endInput = document.getElementById(`inline-day${dayNum}-block${blockIndex}-end-${entryIndex}`);
                    
                    if (startInput && endInput) {
                        const startTime = startInput.value.trim();
                        const endTime = endInput.value.trim();
                        
                        if (startTime && endTime) {
                            updatedBlocks.push(`${startTime} - ${endTime}`);
                        }
                    } else {
                        // Keep block if no inputs found (shouldn't happen, but safety)
                        updatedBlocks.push(block);
                    }
                });
                
                // Apply additions from temporary state
                if (tempNewBlocks[dayNum] && Array.isArray(tempNewBlocks[dayNum])) {
                    tempNewBlocks[dayNum].forEach(newBlock => {
                        updatedBlocks.push(newBlock);
                    });
                }
                
                // Update clock time with edited blocks
                const newClockTime = updatedBlocks.join(', ');
                newClockTimes.push(newClockTime);
                
                // Recalculate total time from blocks and validate
                let totalSeconds = 0;
                let hasInvalidBlock = false;
                updatedBlocks.forEach(block => {
                    const [startStr, endStr] = block.split('-').map(s => s.trim());
                    if (startStr && endStr) {
                        const start = parseClockTime(startStr);
                        const end = parseClockTime(endStr);
                        if (start && end) {
                            const diff = end - start;
                            if (diff > 0) {
                                totalSeconds += Math.floor(diff / 1000);
                            } else {
                                hasInvalidBlock = true;
                            }
                        }
                    }
                });
                
                // Alert if there are invalid time blocks
                if (hasInvalidBlock) {
                    showAlert(`Day ${dayNum} has invalid time blocks where end time is before or equal to start time!`, 'error');
                    return;
                }
                
                newDayTimes.push(formatSecondsToHHMMSS(totalSeconds));
            }

            // Validate
            if (!newProjectName || !newProjectNumber || !newTask) {
                showAlert('Project Name, Project Number, and Task are required!', 'error');
                return;
            }

            // Check if anything changed
            let hasChanges = false;
            if (newProjectName !== entry.projectNameFilter || 
                newProjectNumber !== entry.project || 
                newTask !== entry.task) {
                hasChanges = true;
            }
            
            // Check if any day times or clock times changed
            for (let i = 0; i < 5; i++) {
                if (newDayTimes[i] !== (entry[`day${i + 1}_hr`] || '00:00:00') ||
                    newClockTimes[i] !== (entry[`day${i + 1}_clocktime`] || '')) {
                    hasChanges = true;
                    break;
                }
            }
            
            if (!hasChanges) {
                // No changes, just cancel
                cancelInlineEdit(entryIndex);
                return;
            }

            // Update the entry
            entry.projectNameFilter = newProjectName;
            entry.project = newProjectNumber;
            entry.task = newTask;
            
            // Update day times and clock times
            for (let i = 0; i < 5; i++) {
                entry[`day${i + 1}_hr`] = newDayTimes[i];
                entry[`day${i + 1}_clocktime`] = newClockTimes[i];
            }

            // Update history
            projectNameHistory.add(newProjectName);
            projectHistory.add(newProjectNumber);
            taskHistory.add(newTask);

            // Update structured history
            if (!structuredHistory[newProjectName]) {
                structuredHistory[newProjectName] = { projects: new Set(), tasks: new Set(), comments: new Set() };
            }
            structuredHistory[newProjectName].projects.add(newProjectNumber);
            structuredHistory[newProjectName].tasks.add(newTask);

            // Clear temporary time block data
            if (row) {
                delete row.dataset.tempNewBlocks;
                delete row.dataset.tempRemovedBlocks;
            }

            // Remove Escape key handler
            if (window.inlineEditHandlers && window.inlineEditHandlers[entryIndex]) {
                document.removeEventListener('keydown', window.inlineEditHandlers[entryIndex]);
                delete window.inlineEditHandlers[entryIndex];
            }

            // Save and refresh
            saveHistory();
            saveData();
            updateSummary();
            updateDropdowns();
            updateWeekView();

            showAlert('Entry updated successfully!', 'success');
        }

        // Cancel inline edit
        function cancelInlineEdit(entryIndex) {
            const row = document.getElementById(`row-${entryIndex}`);
            if (!row) return;

            // Clear temporary time block data
            delete row.dataset.tempNewBlocks;
            delete row.dataset.tempRemovedBlocks;

            row.classList.remove('edit-mode-active');
            
            // Remove Escape key handler
            if (window.inlineEditHandlers && window.inlineEditHandlers[entryIndex]) {
                document.removeEventListener('keydown', window.inlineEditHandlers[entryIndex]);
                delete window.inlineEditHandlers[entryIndex];
            }
            
            // Refresh the table to restore original state
            updateSummary();
        }

        // Edit cell (time or comment) in summary table
        function editCell(entryIndex, day, type) {
            const entry = timeEntries[entryIndex];
            if (!entry) {
                showAlert('Entry not found!', 'error');
                return;
            }

            if (type === 'time') {
                const currentTime = entry[`day${day}_hr`] || '00:00:00';
                const newTime = prompt(
                    `Edit time for day ${day} (format: HH:MM:SS):\n\nCurrent: ${currentTime}`,
                    currentTime
                );

                if (newTime === null) return; // User cancelled

                // Validate time format
                const timeRegex = /^([0-9]{1,2}):([0-9]{2}):([0-9]{2})$/;
                const match = newTime.trim().match(timeRegex);
                
                if (!match) {
                    showAlert('Invalid time format! Use HH:MM:SS (e.g., 08:30:00)', 'error');
                    return;
                }

                const hours = parseInt(match[1]);
                const minutes = parseInt(match[2]);
                const seconds = parseInt(match[3]);

                if (minutes >= 60 || seconds >= 60) {
                    showAlert('Invalid time! Minutes and seconds must be less than 60', 'error');
                    return;
                }

                // Format with leading zeros
                const formattedTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                
                entry[`day${day}_hr`] = formattedTime;
                saveData();
                updateSummary();
                updateWeekView();
                showAlert('Time updated successfully!', 'success');

            } else if (type === 'comment') {
                const currentComment = entry[`day${day}_comment`] || '';
                const newComment = prompt(
                    `Edit comment for day ${day}:`,
                    currentComment
                );

                if (newComment === null) return; // User cancelled

                entry[`day${day}_comment`] = newComment.trim();
                
                // Add to history if not empty
                if (newComment.trim()) {
                    commentHistory.add(newComment.trim());
                    const projName = entry.projectNameFilter || 'Uncategorized';
                    if (structuredHistory[projName]) {
                        structuredHistory[projName].comments.add(newComment.trim());
                    }
                    saveHistory();
                    updateDropdowns();
                }

                saveData();
                updateSummary();
                updateWeekView();
                showAlert('Comment updated successfully!', 'success');
            }
        }

        // Show alert
        function showAlert(message, type = 'info') {
            const alertContainer = document.getElementById('alertContainer');
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            
            alertContainer.innerHTML = '';
            alertContainer.appendChild(alertDiv);
            
            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        // Save data to localStorage
        function saveData() {
            const { monday, friday } = getWeekDates();
            const weekKey = `${monday.toISOString().split('T')[0]}`;
            
            const data = {
                weekStart: monday.toISOString(),
                weekEnd: friday.toISOString(),
                entries: timeEntries
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            
            // Also save to all weeks history
            saveToAllWeeks(weekKey, data);
        }

        // Save current week to all weeks history
        function saveToAllWeeks(weekKey, data) {
            let allWeeks = {};
            const saved = localStorage.getItem(ALL_WEEKS_KEY);
            if (saved) {
                try {
                    allWeeks = JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading all weeks data:', e);
                }
            }
            
            // Update or add current week
            allWeeks[weekKey] = data;
            
            localStorage.setItem(ALL_WEEKS_KEY, JSON.stringify(allWeeks));
        }

        // Get all saved weeks
        function getAllWeeks() {
            const saved = localStorage.getItem(ALL_WEEKS_KEY);
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading all weeks data:', e);
                    return {};
                }
            }
            return {};
        }

        // Load data from localStorage
        function loadData() {
            const { monday } = getWeekDates();
            const weekKey = monday.toISOString().split('T')[0];
            
            // If viewing current week (weekOffset = 0), load from STORAGE_KEY
            if (weekOffset === 0) {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        const savedMonday = new Date(data.weekStart);
                        
                        // Only load if same week
                        if (savedMonday.toDateString() === monday.toDateString()) {
                            timeEntries = data.entries || [];
                        } else {
                            timeEntries = [];
                        }
                    } catch (e) {
                        console.error('Error loading data:', e);
                        timeEntries = [];
                    }
                } else {
                    timeEntries = [];
                }
            } else {
                // Load from historical weeks
                const allWeeks = getAllWeeks();
                if (allWeeks[weekKey]) {
                    timeEntries = allWeeks[weekKey].entries || [];
                } else {
                    timeEntries = [];
                }
            }
        }

        // Load history from localStorage
        function loadHistory() {
            const saved = localStorage.getItem(HISTORY_KEY);
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    projectNameHistory = new Set(data.projectNames || []);
                    projectHistory = new Set(data.projects || []);
                    taskHistory = new Set(data.tasks || []);
                    commentHistory = new Set(data.comments || []);
                    
                    // Convert structured history arrays back to Sets
                    structuredHistory = {};
                    if (data.structured) {
                        Object.keys(data.structured).forEach(projName => {
                            structuredHistory[projName] = {
                                projects: new Set(data.structured[projName].projects || []),
                                tasks: new Set(data.structured[projName].tasks || []),
                                comments: new Set(data.structured[projName].comments || [])
                            };
                        });
                    }
                    
                    console.log('Loaded structured history:', structuredHistory);
                    console.log('Total project names:', projectNameHistory.size);
                    console.log('Total projects:', projectHistory.size);
                    console.log('Total tasks:', taskHistory.size);
                } catch (e) {
                    console.error('Error loading history:', e);
                    projectNameHistory = new Set();
                    projectHistory = new Set();
                    taskHistory = new Set();
                    commentHistory = new Set();
                    structuredHistory = {};
                }
            }
        }

        // Load last active task from localStorage and populate form
        function loadLastTask() {
            const saved = localStorage.getItem(LAST_TASK_KEY);
            if (saved) {
                try {
                    lastActiveTask = JSON.parse(saved);
                    console.log('Loaded last active task:', lastActiveTask);
                    
                    // Auto-populate form fields with last task (but don't start timer)
                    if (lastActiveTask.projectNameFilter) {
                        document.getElementById('projectNameFilter').value = lastActiveTask.projectNameFilter;
                    }
                    if (lastActiveTask.project) {
                        document.getElementById('projectName').value = lastActiveTask.project;
                    }
                    if (lastActiveTask.task) {
                        document.getElementById('taskName').value = lastActiveTask.task;
                    }
                    
                    // Show info message if task was loaded
                    if (lastActiveTask.projectNameFilter || lastActiveTask.project || lastActiveTask.task) {
                        setTimeout(() => {
                            showAlert('Last task loaded. Click "Start Timer" to continue.', 'info');
                        }, 500);
                    }
                } catch (e) {
                    console.error('Error loading last task:', e);
                    lastActiveTask = null;
                }
            }
        }

        // Save last active task to localStorage
        function saveLastTask() {
            if (lastActiveTask) {
                try {
                    localStorage.setItem(LAST_TASK_KEY, JSON.stringify(lastActiveTask));
                } catch (e) {
                    console.error('Error saving last task:', e);
                }
            }
        }

        // Populate history from current timecard entries
        function populateHistoryFromEntries() {
            timeEntries.forEach(entry => {
                if (entry.projectNameFilter) projectNameHistory.add(entry.projectNameFilter);
                if (entry.project) projectHistory.add(entry.project);
                if (entry.task) taskHistory.add(entry.task);
                
                // Build structured history
                const projName = entry.projectNameFilter || 'Uncategorized';
                if (!structuredHistory[projName]) {
                    structuredHistory[projName] = {
                        projects: new Set(),
                        tasks: new Set(),
                        comments: new Set()
                    };
                }
                if (entry.project) structuredHistory[projName].projects.add(entry.project);
                if (entry.task) structuredHistory[projName].tasks.add(entry.task);
                
                // Add all non-empty comments from all days
                for (let i = 1; i <= 5; i++) {
                    const comment = entry[`day${i}_comment`];
                    if (comment && comment.trim()) {
                        // Split by semicolon in case multiple comments were concatenated
                        comment.split(';').forEach(c => {
                            const trimmed = c.trim();
                            if (trimmed) {
                                commentHistory.add(trimmed);
                                structuredHistory[projName].comments.add(trimmed);
                            }
                        });
                    }
                }
            });
            saveHistory();
        }

        // Save history to localStorage
        function saveHistory() {
            // Convert Sets to Arrays for structured history
            const structuredForStorage = {};
            Object.keys(structuredHistory).forEach(projName => {
                structuredForStorage[projName] = {
                    projects: Array.from(structuredHistory[projName].projects),
                    tasks: Array.from(structuredHistory[projName].tasks),
                    comments: Array.from(structuredHistory[projName].comments)
                };
            });

            const data = {
                projectNames: Array.from(projectNameHistory),
                projects: Array.from(projectHistory),
                tasks: Array.from(taskHistory),
                comments: Array.from(commentHistory),
                structured: structuredForStorage
            };
            localStorage.setItem(HISTORY_KEY, JSON.stringify(data));
        }

        // Add to history
        function addToHistory(projectNameFilter, project, task, comment) {
            if (projectNameFilter) {
                projectNameHistory.add(projectNameFilter);
            }
            if (project) {
                projectHistory.add(project);
            }
            if (task) {
                taskHistory.add(task);
            }
            if (comment) {
                commentHistory.add(comment);
            }

            // Add to structured history
            if (projectNameFilter) {
                if (!structuredHistory[projectNameFilter]) {
                    structuredHistory[projectNameFilter] = {
                        projects: new Set(),
                        tasks: new Set(),
                        comments: new Set()
                    };
                }
                if (project) structuredHistory[projectNameFilter].projects.add(project);
                if (task) structuredHistory[projectNameFilter].tasks.add(task);
                if (comment) structuredHistory[projectNameFilter].comments.add(comment);
            }

            saveHistory();
            updateDropdowns();
        }

        // Update dropdown lists
        function updateDropdowns() {
            // Update project name list
            const projectNameList = document.getElementById('projectNameList');
            projectNameList.innerHTML = '';
            const projectNames = Array.from(projectNameHistory).sort();
            projectNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                projectNameList.appendChild(option);
            });
            document.getElementById('projectNameCount').textContent = 
                projectNames.length > 0 ? `(${projectNames.length} saved)` : '';

            // Get selected project name filter
            const selectedProjectName = document.getElementById('projectNameFilter').value.trim();

            // Update project list (filtered if project name is selected)
            const projectList = document.getElementById('projectList');
            projectList.innerHTML = '';
            let projects;
            
            if (selectedProjectName && structuredHistory[selectedProjectName]) {
                // Convert Set back to Array for filtering
                const projSet = structuredHistory[selectedProjectName].projects;
                projects = Array.from(projSet instanceof Set ? projSet : new Set(projSet)).sort();
            } else {
                projects = Array.from(projectHistory).sort();
            }
            
            projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project;
                projectList.appendChild(option);
            });
            document.getElementById('projectCount').textContent = 
                projects.length > 0 ? `(${projects.length} saved)` : '';

            // Update task list (filtered if project name is selected)
            const taskList = document.getElementById('taskList');
            taskList.innerHTML = '';
            let tasks;
            
            if (selectedProjectName && structuredHistory[selectedProjectName]) {
                const taskSet = structuredHistory[selectedProjectName].tasks;
                tasks = Array.from(taskSet instanceof Set ? taskSet : new Set(taskSet)).sort();
            } else {
                tasks = Array.from(taskHistory).sort();
            }
            
            tasks.forEach(task => {
                const option = document.createElement('option');
                option.value = task;
                taskList.appendChild(option);
            });
            document.getElementById('taskCount').textContent = 
                tasks.length > 0 ? `(${tasks.length} saved)` : '';

            // Update comment count (filtered if project name is selected)
            let comments;
            
            if (selectedProjectName && structuredHistory[selectedProjectName]) {
                const commentSet = structuredHistory[selectedProjectName].comments;
                comments = Array.from(commentSet instanceof Set ? commentSet : new Set(commentSet)).sort();
            } else {
                comments = Array.from(commentHistory).sort();
            }
            
            document.getElementById('commentCount').textContent = 
                comments.length > 0 ? `(${comments.length} saved)` : '';
        }

        // Setup input listeners for dynamic filtering
        function setupInputListeners() {
            // When project name filter changes, update other dropdowns and clear dependent fields
            document.getElementById('projectNameFilter').addEventListener('input', function(e) {
                // Clear dependent fields when project name changes
                document.getElementById('projectName').value = '';
                document.getElementById('taskName').value = '';
                document.getElementById('comment').value = '';
                
                // Update dropdowns with filtered data
                updateDropdowns();
            });

            // Auto-populate from existing entries when project is selected
            document.getElementById('projectName').addEventListener('input', function(e) {
                const selectedProjectName = document.getElementById('projectNameFilter').value.trim();
                const selectedProject = e.target.value;
                
                if (selectedProjectName && selectedProject) {
                    // Find matching entries for this project name + project combination
                    const matchingEntries = timeEntries.filter(entry => 
                        entry.projectNameFilter === selectedProjectName && 
                        entry.project === selectedProject
                    );
                    
                    if (matchingEntries.length > 0) {
                        // Get unique tasks for this combination
                        const projectTasks = new Set(matchingEntries.map(entry => entry.task));
                        
                        // Update task datalist with filtered options
                        const taskList = document.getElementById('taskList');
                        taskList.innerHTML = '';
                        Array.from(projectTasks).sort().forEach(task => {
                            const option = document.createElement('option');
                            option.value = task;
                            taskList.appendChild(option);
                        });
                    }
                }
            });

            // Setup comment dropdown
            setupCommentDropdown();
        }

        // Setup custom comment dropdown with filtering
        function setupCommentDropdown() {
            const commentInput = document.getElementById('comment');
            const commentDropdown = document.getElementById('commentDropdown');
            let selectedIndex = -1;

            // Show dropdown on focus or input
            commentInput.addEventListener('focus', function() {
                showCommentDropdown();
            });

            commentInput.addEventListener('input', function() {
                showCommentDropdown();
            });

            // Handle when user finishes entering comment (blur or Enter key)
            let lastCommentValue = '';
            commentInput.addEventListener('blur', function() {
                const currentValue = commentInput.value.trim();
                if (currentValue && currentValue !== lastCommentValue) {
                    lastCommentValue = currentValue;
                    handleCommentChange(currentValue);
                }
            });
            
            // Hide dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!commentInput.contains(e.target) && !commentDropdown.contains(e.target)) {
                    commentDropdown.classList.remove('show');
                }
            });

            // Keyboard navigation and Enter key handling
            commentInput.addEventListener('keydown', function(e) {
                const options = commentDropdown.querySelectorAll('.comment-option');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, options.length - 1);
                    updateSelectedOption(options);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelectedOption(options);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    options[selectedIndex].click();
                } else if (e.key === 'Enter' && selectedIndex < 0 && !e.shiftKey) {
                    // User pressed Enter without selecting from dropdown
                    const currentValue = commentInput.value.trim();
                    if (currentValue && currentValue !== lastCommentValue) {
                        lastCommentValue = currentValue;
                        handleCommentChange(currentValue);
                    }
                } else if (e.key === 'Escape') {
                    commentDropdown.classList.remove('show');
                }
            });

            function updateSelectedOption(options) {
                options.forEach((opt, idx) => {
                    opt.classList.toggle('selected', idx === selectedIndex);
                });
                if (selectedIndex >= 0 && options[selectedIndex]) {
                    options[selectedIndex].scrollIntoView({ block: 'nearest' });
                }
            }

            function showCommentDropdown() {
                const selectedProjectName = document.getElementById('projectNameFilter').value.trim();
                const currentValue = commentInput.value.toLowerCase();
                
                // Get filtered comments based on project name
                let comments;
                if (selectedProjectName && structuredHistory[selectedProjectName]) {
                    const commentSet = structuredHistory[selectedProjectName].comments;
                    comments = Array.from(commentSet instanceof Set ? commentSet : new Set(commentSet));
                } else {
                    comments = Array.from(commentHistory);
                }

                // Filter by current input value
                const filteredComments = comments
                    .filter(c => c.toLowerCase().includes(currentValue))
                    .sort();

                // Build dropdown HTML
                commentDropdown.innerHTML = '';
                selectedIndex = -1;

                if (filteredComments.length === 0) {
                    commentDropdown.classList.remove('show');
                    return;
                }

                filteredComments.forEach(comment => {
                    const option = document.createElement('div');
                    option.className = 'comment-option';
                    option.textContent = comment;
                    option.addEventListener('click', function() {
                        commentInput.value = comment;
                        commentDropdown.classList.remove('show');
                        commentInput.focus();
                        // Handle comment change for running timer
                        handleCommentChange(comment);
                    });
                    commentDropdown.appendChild(option);
                });

                commentDropdown.classList.add('show');
            }
        }

        // Handle comment change when timer is running
        function handleCommentChange(newComment) {
            // Only act if timer is running
            if (!startTime) return;
            
            const projectNameFilter = document.getElementById('projectNameFilter').value.trim();
            const project = document.getElementById('projectName').value.trim();
            const task = document.getElementById('taskName').value.trim();
            
            if (!projectNameFilter || !project || !task) return;
            
            // Save the current running entry
            const endTime = Date.now();
            const elapsedSeconds = Math.floor((endTime - startTime) / 1000);
            const currentDay = getCurrentWeekday();
            
            // Format clock times
            const fromTime = formatClockTime(new Date(startTime));
            const toTime = formatClockTime(new Date(endTime));
            const clockTimeRange = `${fromTime} - ${toTime}`;
            
            // Find existing entry
            let entry = timeEntries.find(e => e.projectNameFilter === projectNameFilter && e.project === project && e.task === task);
            
            if (entry) {
                // Update existing entry
                const existingTime = entry[`day${currentDay}_hr`] || '00:00:00';
                const existingSeconds = parseHHMMSSToSeconds(existingTime);
                const totalSeconds = existingSeconds + elapsedSeconds;
                entry[`day${currentDay}_hr`] = formatSecondsToHHMMSS(totalSeconds);
                
                // Append clock time range
                const existingClockTime = entry[`day${currentDay}_clocktime`] || '';
                if (existingClockTime) {
                    entry[`day${currentDay}_clocktime`] = `${existingClockTime}, ${clockTimeRange}`;
                } else {
                    entry[`day${currentDay}_clocktime`] = clockTimeRange;
                }
                
                // Update comment if it was empty initially
                const existingComment = entry[`day${currentDay}_comment`] || '';
                if (!existingComment && newComment) {
                    entry[`day${currentDay}_comment`] = newComment;
                } else if (existingComment && newComment) {
                    // Check if the new comment already exists
                    const existingComments = existingComment.split(';').map(c => c.trim());
                    if (!existingComments.includes(newComment.trim())) {
                        entry[`day${currentDay}_comment`] = `${existingComment}; ${newComment}`;
                    }
                }
                
                saveData();
                updateSummary();
                
                // Continue the timer with updated comment
                startTime = Date.now();
                showAlert('Entry saved and timer continuing with updated comment', 'success');
                
            } else {
                // Create new entry and restart timer
                entry = { projectNameFilter, project, task };
                for (let i = 1; i <= 5; i++) {
                    entry[`day${i}_hr`] = '00:00:00';
                    entry[`day${i}_comment`] = '';
                    entry[`day${i}_clocktime`] = '';
                }
                entry[`day${currentDay}_hr`] = formatSecondsToHHMMSS(elapsedSeconds);
                entry[`day${currentDay}_comment`] = newComment;
                entry[`day${currentDay}_clocktime`] = clockTimeRange;
                timeEntries.push(entry);
                
                saveData();
                updateSummary();
                
                // Restart the timer for new entry
                startTime = Date.now();
                showAlert('Entry saved and timer restarted', 'success');
            }
            
            updateWeekView();
        }

        // Import from Excel
        function importFromExcel(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    // Check if this is a multi-week export
                    const isMultiWeek = workbook.SheetNames.length > 1 || workbook.SheetNames[0].startsWith('Week ');
                    
                    if (isMultiWeek) {
                        // Handle multi-week import
                        importAllWeeksFromExcel(workbook);
                        return;
                    }
                    
                    // Single week import (existing logic)
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    
                    // Convert to JSON
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);
                    
                    if (jsonData.length === 0) {
                        showAlert('No data found in the Excel file!', 'error');
                        return;
                    }

                    // Ask user if they want to merge or replace
                    const mergeChoice = confirm(
                        'Import Options:\n\n' +
                        'Click OK to MERGE imported data with existing data.\n' +
                        'Click Cancel to REPLACE all existing data with imported data.\n\n' +
                        'Note: Merging will add times together for matching entries.'
                    );

                    if (!mergeChoice) {
                        // Clear existing data
                        timeEntries = [];
                    }

                    let importedCount = 0;
                    let skippedCount = 0;

                    // Process each row
                    jsonData.forEach(row => {
                        // Skip subtotal and total rows
                        const task = row['Task'] || '';
                        if (task.includes('Subtotal') || task.includes('Total')) {
                            skippedCount++;
                            return;
                        }

                        // Skip rows without required data
                        const projectName = row['Project Name'] || '';
                        const projectNumber = row['Project Number'] || '';
                        
                        if (!projectName || !projectNumber || !task) {
                            skippedCount++;
                            return;
                        }

                        // Check if entry already exists (for merging)
                        let entry = timeEntries.find(e => 
                            e.projectNameFilter === projectName && 
                            e.project === projectNumber && 
                            e.task === task
                        );

                        if (!entry) {
                            // Create new entry
                            entry = {
                                projectNameFilter: projectName,
                                project: projectNumber,
                                task: task
                            };
                            for (let i = 1; i <= 5; i++) {
                                entry[`day${i}_hr`] = '00:00:00';
                                entry[`day${i}_comment`] = '';
                            }
                            timeEntries.push(entry);
                        }

                        // Import time data for each day
                        const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];
                        days.forEach((dayLabel, index) => {
                            const dayNum = index + 1;
                            const importedTime = row[dayLabel] || '00:00:00';
                            const importedComment = row[`${dayLabel} Comment`] || '';
                            const importedClockTime = row[`${dayLabel} Clock Time`] || '';

                            if (importedTime && importedTime !== '00:00:00') {
                                if (mergeChoice) {
                                    // Merge: add times together
                                    const existingSeconds = parseHHMMSSToSeconds(entry[`day${dayNum}_hr`] || '00:00:00');
                                    const importedSeconds = parseHHMMSSToSeconds(importedTime);
                                    const totalSeconds = existingSeconds + importedSeconds;
                                    entry[`day${dayNum}_hr`] = formatSecondsToHHMMSS(totalSeconds);
                                } else {
                                    // Replace: use imported time
                                    entry[`day${dayNum}_hr`] = importedTime;
                                }
                            }

                            // Handle comments
                            if (importedComment) {
                                const existingComment = entry[`day${dayNum}_comment`] || '';
                                if (mergeChoice && existingComment) {
                                    // Merge comments
                                    const existingComments = existingComment.split(';').map(c => c.trim());
                                    const importedCommentTrimmed = importedComment.trim();
                                    if (!existingComments.includes(importedCommentTrimmed)) {
                                        entry[`day${dayNum}_comment`] = `${existingComment}; ${importedComment}`;
                                    }
                                } else {
                                    entry[`day${dayNum}_comment`] = importedComment;
                                }
                            }

                            // Handle clock time
                            if (importedClockTime) {
                                entry[`day${dayNum}_clocktime`] = importedClockTime;
                            }
                        });

                        // Add to history
                        addToHistory(projectName, projectNumber, task, '');
                        importedCount++;
                    });

                    // Save and update UI
                    saveData();
                    updateSummary();
                    
                    const mode = mergeChoice ? 'merged with' : 'replaced';
                    showAlert(
                        `Import successful! ${importedCount} entries ${mode} existing data. ${skippedCount} rows skipped (subtotals/empty rows).`,
                        'success'
                    );

                } catch (error) {
                    console.error('Import error:', error);
                    showAlert('Error importing file. Please ensure it is a valid Excel file exported from this application.', 'error');
                }
            };

            reader.onerror = function() {
                showAlert('Error reading file. Please try again.', 'error');
            };

            reader.readAsArrayBuffer(file);
            
            // Reset file input so the same file can be imported again
            event.target.value = '';
        }

        // Import from Outlook .ics file
        function importFromICS(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const icsText = e.target.result;
                    const events = parseICS(icsText);
                    if (!events || events.length === 0) {
                        showAlert('No events found in the .ics file', 'error');
                        return;
                    }

                    // Map events into current week's days
                    const { monday } = getWeekDates();
                    let importedCount = 0;

                    events.forEach(ev => {
                        // We only handle events that overlap Mon-Fri of the current week
                        const evStart = new Date(ev.dtstart);
                        const evEnd = new Date(ev.dtend || ev.dtstart);

                        // For recurring events RRULE, we ignore recurrence expansion for now
                        // Only include single-instance events
                        for (let dayOffset = 0; dayOffset < 5; dayOffset++) {
                            const dayDate = new Date(monday);
                            dayDate.setDate(monday.getDate() + dayOffset);

                            // If event occurs on this day (start before end of day and end after start of day)
                            const dayStart = new Date(dayDate);
                            dayStart.setHours(0,0,0,0);
                            const dayEnd = new Date(dayDate);
                            dayEnd.setHours(23,59,59,999);

                            if (evEnd <= dayStart || evStart >= dayEnd) continue;

                            // Compute clipped start and end times within the day
                            const clipStart = evStart < dayStart ? dayStart : evStart;
                            const clipEnd = evEnd > dayEnd ? dayEnd : evEnd;

                            // Format times as 'H:MM AM/PM'
                            const startStr = formatClockTime(clipStart);
                            const endStr = formatClockTime(clipEnd);

                            // Heuristic: split summary into Project - Task if possible
                            let projectName = ev.summary || 'Calendar Event';
                            let projectNumber = '';
                            let task = '';
                            if (projectName.includes(' - ')) {
                                const parts = projectName.split(' - ');
                                projectName = parts[0].trim();
                                task = parts.slice(1).join(' - ').trim();
                            } else {
                                task = projectName;
                            }

                            // Create or find entry
                            let entry = timeEntries.find(e => e.projectNameFilter === projectName && e.task === task);
                            if (!entry) {
                                entry = { projectNameFilter: projectName, project: projectNumber, task: task };
                                for (let i = 1; i <= 5; i++) {
                                    entry[`day${i}_hr`] = '00:00:00';
                                    entry[`day${i}_comment`] = '';
                                    entry[`day${i}_clocktime`] = '';
                                }
                                timeEntries.push(entry);
                            }

                            const dayIndex = dayOffset + 1; // Monday=1
                            const clockKey = `day${dayIndex}_clocktime`;
                            const existing = entry[clockKey] || '';
                            const range = `${startStr} - ${endStr}`;
                            entry[clockKey] = existing ? `${existing}, ${range}` : range;

                            // Recalculate day total
                            const clockRanges = entry[clockKey].split(',').map(r => r.trim()).filter(r => r);
                            let totalSeconds = 0;
                            clockRanges.forEach(rangeItem => {
                                const [s,e] = rangeItem.split('-').map(x => x.trim());
                                if (s && e) {
                                    totalSeconds += (parseTimeToMinutes(e) - parseTimeToMinutes(s)) * 60;
                                }
                            });
                            entry[`day${dayIndex}_hr`] = formatSecondsToHHMMSS(totalSeconds);
                            importedCount++;
                        }
                    });

                    if (importedCount > 0) {
                        saveData();
                        updateSummary();
                        updateWeekView();
                        showAlert(`Imported ${importedCount} events from calendar`, 'success');
                    } else {
                        showAlert('No events imported for the current week', 'info');
                    }

                } catch (err) {
                    console.error('ICS import error', err);
                    showAlert('Error importing .ics file', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Very small ICS parser to extract VEVENT dtstart/dtend/summary (no RRULE or complex parsing)
        function parseICS(icsText) {
            const lines = icsText.split(/\r?\n/);
            const events = [];
            let current = null;

            lines.forEach(line => {
                if (line.startsWith('BEGIN:VEVENT')) {
                    current = {};
                } else if (line.startsWith('END:VEVENT')) {
                    if (current) events.push(current);
                    current = null;
                } else if (current) {
                    const idx = line.indexOf(':');
                    if (idx > -1) {
                        const key = line.substring(0, idx).split(';')[0];
                        const val = line.substring(idx+1).trim();
                        if (key === 'DTSTART') current.dtstart = val;
                        else if (key === 'DTEND') current.dtend = val;
                        else if (key === 'SUMMARY') current.summary = val;
                    }
                }
            });

            // Normalize dates
            return events.map(ev => {
                const normalize = (v) => {
                    // Handle basic formats like 20251121T090000Z or 20251121T090000
                    if (!v) return null;
                    const m = v.match(/(\d{4})(\d{2})(\d{2})T?(\d{2})(\d{2})(\d{2})Z?/);
                    if (m) {
                        return new Date(Date.UTC(parseInt(m[1]), parseInt(m[2])-1, parseInt(m[3]), parseInt(m[4]), parseInt(m[5]), parseInt(m[6])));
                    }
                    // Fallback parse
                    const d = new Date(v);
                    return isNaN(d.getTime()) ? null : d;
                };
                return {
                    dtstart: normalize(ev.dtstart),
                    dtend: normalize(ev.dtend),
                    summary: ev.summary || ''
                };
            }).filter(e => e.dtstart);
        }

        // Import all weeks from multi-sheet Excel file
        function importAllWeeksFromExcel(workbook) {
            try {
                const mergeChoice = confirm(
                    'Multi-Week Import Detected!\n\n' +
                    `This file contains ${workbook.SheetNames.length} week(s) of data.\n\n` +
                    'Click OK to MERGE with existing historical data.\n' +
                    'Click Cancel to REPLACE all historical data.\n\n' +
                    'Note: Current week data will be preserved unless it matches an imported week.'
                );

                let allWeeks = mergeChoice ? getAllWeeks() : {};
                let totalImported = 0;
                let totalSkipped = 0;

                // Process each sheet
                workbook.SheetNames.forEach(sheetName => {
                    // Extract week date from sheet name (format: "Week MM-DD-YYYY")
                    const dateMatch = sheetName.match(/Week (\d{2})-(\d{2})-(\d{4})/);
                    if (!dateMatch) {
                        totalSkipped++;
                        return;
                    }

                    const [_, month, day, year] = dateMatch;
                    const weekStart = new Date(`${year}-${month}-${day}`);
                    
                    // Calculate week end (Friday)
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekEnd.getDate() + 4);

                    // Read sheet data
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);

                    if (jsonData.length === 0) {
                        totalSkipped++;
                        return;
                    }

                    // Process entries for this week
                    const weekEntries = [];
                    jsonData.forEach(row => {
                        const task = row['Task'] || '';
                        if (task.includes('Subtotal') || task.includes('Total')) {
                            return;
                        }

                        const projectName = row['Project Name'] || '';
                        const projectNumber = row['Project Number'] || '';
                        
                        if (!projectName || !projectNumber || !task) {
                            return;
                        }

                        const entry = {
                            projectNameFilter: projectName,
                            project: projectNumber,
                            task: task
                        };

                        const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];
                        days.forEach((dayLabel, index) => {
                            const dayNum = index + 1;
                            entry[`day${dayNum}_hr`] = row[dayLabel] || '00:00:00';
                            entry[`day${dayNum}_comment`] = row[`${dayLabel} Comment`] || '';
                            entry[`day${dayNum}_clocktime`] = row[`${dayLabel} Clock Time`] || '';
                        });

                        weekEntries.push(entry);
                        
                        // Add to history
                        addToHistory(projectName, projectNumber, task, '');
                    });

                    if (weekEntries.length > 0) {
                        const weekKey = weekStart.toISOString().split('T')[0];
                        allWeeks[weekKey] = {
                            weekStart: weekStart.toISOString(),
                            weekEnd: weekEnd.toISOString(),
                            entries: weekEntries
                        };
                        totalImported++;
                    }
                });

                // Save all weeks to localStorage
                localStorage.setItem(ALL_WEEKS_KEY, JSON.stringify(allWeeks));

                // Check if current week was imported and update timeEntries
                const { monday } = getWeekDates();
                const currentWeekKey = monday.toISOString().split('T')[0];
                if (allWeeks[currentWeekKey]) {
                    timeEntries = allWeeks[currentWeekKey].entries || [];
                    saveData();
                    updateSummary();
                }

                const mode = mergeChoice ? 'merged with' : 'replaced';
                showAlert(
                    `Import successful! ${totalImported} week(s) ${mode} historical data. ${totalSkipped} sheet(s) skipped.`,
                    'success'
                );

            } catch (error) {
                console.error('Multi-week import error:', error);
                showAlert('Error importing multi-week file. Please ensure it is a valid file exported from this application.', 'error');
            }
        }

        // Export all weeks to Excel with separate tabs
        function exportAllWeeksToExcel() {
            const allWeeks = getAllWeeks();
            const weekKeys = Object.keys(allWeeks).sort();
            
            if (weekKeys.length === 0) {
                showAlert('No historical data to export!', 'error');
                return;
            }

            const wb = XLSX.utils.book_new();
            const formatDate = (date) => {
                const d = new Date(date);
                return `${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}-${d.getFullYear()}`;
            };

            // Process each week
            weekKeys.forEach(weekKey => {
                const weekData = allWeeks[weekKey];
                const entries = weekData.entries || [];
                
                if (entries.length === 0) return; // Skip empty weeks

                const monday = new Date(weekData.weekStart);
                const friday = new Date(weekData.weekEnd);
                
                // Group entries by project name
                const groupedEntries = {};
                entries.forEach(entry => {
                    const projName = entry.projectNameFilter || 'Uncategorized';
                    if (!groupedEntries[projName]) {
                        groupedEntries[projName] = [];
                    }
                    groupedEntries[projName].push(entry);
                });

                // Calculate daily totals
                let dayTotals = [0, 0, 0, 0, 0];

                // Prepare data for Excel
                const excelData = [];
                
                Object.keys(groupedEntries).sort().forEach(projName => {
                    const projectEntries = groupedEntries[projName];
                    let projectDayTotals = [0, 0, 0, 0, 0];

                    // Add entries for this project
                    projectEntries.forEach(entry => {
                        const row = {
                            'Project Name': entry.projectNameFilter || 'Uncategorized',
                            'Project Number': entry.project,
                            'Task': entry.task
                        };
                        
                        for (let i = 1; i <= 5; i++) {
                            const timeStr = entry[`day${i}_hr`] || '00:00:00';
                            const seconds = parseHHMMSSToSeconds(timeStr);
                            projectDayTotals[i - 1] += seconds;
                            dayTotals[i - 1] += seconds;
                            
                            const dayLabel = i === 1 ? 'Mon' : i === 2 ? 'Tue' : i === 3 ? 'Wed' : i === 4 ? 'Thu' : 'Fri';
                            row[dayLabel] = timeStr;
                            row[`${dayLabel} Comment`] = entry[`day${i}_comment`] || '';
                            row[`${dayLabel} Clock Time`] = entry[`day${i}_clocktime`] || '';
                        }
                        
                        // Add total column
                        let totalSeconds = 0;
                        for (let i = 1; i <= 5; i++) {
                            totalSeconds += parseHHMMSSToSeconds(entry[`day${i}_hr`] || '00:00:00');
                        }
                        row['Total'] = formatSecondsToHHMMSS(totalSeconds);
                        
                        excelData.push(row);
                    });

                    // Add project subtotal row
                    const subtotalRow = {
                        'Project Name': '',
                        'Project Number': '',
                        'Task': `${projName} Subtotal`
                    };
                    
                    let projectTotalSeconds = 0;
                    for (let i = 1; i <= 5; i++) {
                        const dayLabel = i === 1 ? 'Mon' : i === 2 ? 'Tue' : i === 3 ? 'Wed' : i === 4 ? 'Thu' : 'Fri';
                        subtotalRow[dayLabel] = formatSecondsToHHMMSS(projectDayTotals[i - 1]);
                        subtotalRow[`${dayLabel} Comment`] = '';
                        subtotalRow[`${dayLabel} Clock Time`] = '';
                        projectTotalSeconds += projectDayTotals[i - 1];
                    }
                    subtotalRow['Total'] = formatSecondsToHHMMSS(projectTotalSeconds);
                    
                    excelData.push(subtotalRow);
                });

                // Add grand total row
                const grandTotalRow = {
                    'Project Name': '',
                    'Project Number': '',
                    'Task': 'Grand Total'
                };
                
                let grandTotalSeconds = 0;
                for (let i = 1; i <= 5; i++) {
                    const dayLabel = i === 1 ? 'Mon' : i === 2 ? 'Tue' : i === 3 ? 'Wed' : i === 4 ? 'Thu' : 'Fri';
                    grandTotalRow[dayLabel] = formatSecondsToHHMMSS(dayTotals[i - 1]);
                    grandTotalRow[`${dayLabel} Comment`] = '';
                    grandTotalRow[`${dayLabel} Clock Time`] = '';
                    grandTotalSeconds += dayTotals[i - 1];
                }
                grandTotalRow['Total'] = formatSecondsToHHMMSS(grandTotalSeconds);
                
                excelData.push(grandTotalRow);

                // Create worksheet
                const ws = XLSX.utils.json_to_sheet(excelData);

                // Set column widths
                ws['!cols'] = [
                    { wch: 20 },  // Project Name
                    { wch: 20 },  // Project Number
                    { wch: 25 },  // Task
                    { wch: 12 },  // Mon time
                    { wch: 35 },  // Mon comment
                    { wch: 20 },  // Mon clock time
                    { wch: 12 },  // Tue time
                    { wch: 35 },  // Tue comment
                    { wch: 20 },  // Tue clock time
                    { wch: 12 },  // Wed time
                    { wch: 35 },  // Wed comment
                    { wch: 20 },  // Wed clock time
                    { wch: 12 },  // Thu time
                    { wch: 35 },  // Thu comment
                    { wch: 20 },  // Thu clock time
                    { wch: 12 },  // Fri time
                    { wch: 35 },  // Fri comment
                    { wch: 20 },  // Fri clock time
                    { wch: 12 }   // Total
                ];

                // Create sheet name from week dates
                const sheetName = `Week ${formatDate(monday)}`;
                XLSX.utils.book_append_sheet(wb, ws, sheetName);
            });

            // Save workbook
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `timecard_all_weeks_${timestamp}.xlsx`;
            XLSX.writeFile(wb, filename);
            
            showAlert(`Exported ${weekKeys.length} week(s) to ${filename}`, 'success');
        }

        // Export to Excel
        function exportToExcel() {
            if (timeEntries.length === 0) {
                showAlert('No data to export!', 'error');
                return;
            }

            const { monday, friday } = getWeekDates();
            const formatDate = (date) => {
                return `${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}-${date.getFullYear()}`;
            };

            // Group entries by project name
            const groupedEntries = {};
            timeEntries.forEach(entry => {
                const projName = entry.projectNameFilter || 'Uncategorized';
                if (!groupedEntries[projName]) {
                    groupedEntries[projName] = [];
                }
                groupedEntries[projName].push(entry);
            });

            // Calculate daily totals
            let dayTotals = [0, 0, 0, 0, 0];

            // Prepare data for Excel with grouping and subtotals
            const excelData = [];
            
            Object.keys(groupedEntries).sort().forEach(projName => {
                const entries = groupedEntries[projName];
                let projectDayTotals = [0, 0, 0, 0, 0];

                // Add entries for this project
                entries.forEach(entry => {
                    const row = {
                        'Project Name': entry.projectNameFilter || 'Uncategorized',
                        'Project Number': entry.project,
                        'Task': entry.task
                    };
                    
                    for (let i = 1; i <= 5; i++) {
                        const timeStr = entry[`day${i}_hr`] || '00:00:00';
                        const seconds = parseHHMMSSToSeconds(timeStr);
                        projectDayTotals[i - 1] += seconds;
                        dayTotals[i - 1] += seconds;
                        
                        const dayLabel = i === 1 ? 'Mon' : i === 2 ? 'Tue' : i === 3 ? 'Wed' : i === 4 ? 'Thu' : 'Fri';
                        row[dayLabel] = timeStr;
                        row[`${dayLabel} Comment`] = entry[`day${i}_comment`] || '';
                        row[`${dayLabel} Clock Time`] = entry[`day${i}_clocktime`] || '';
                    }
                    
                    // Add total column
                    let totalSeconds = 0;
                    for (let i = 1; i <= 5; i++) {
                        totalSeconds += parseHHMMSSToSeconds(entry[`day${i}_hr`] || '00:00:00');
                    }
                    row['Total'] = formatSecondsToHHMMSS(totalSeconds);
                    
                    excelData.push(row);
                });

                // Add project subtotal row
                const subtotalRow = {
                    'Project Name': '',
                    'Project Number': '',
                    'Task': `${projName} Subtotal`
                };
                
                let projectTotalSeconds = 0;
                for (let i = 1; i <= 5; i++) {
                    const dayLabel = i === 1 ? 'Mon' : i === 2 ? 'Tue' : i === 3 ? 'Wed' : i === 4 ? 'Thu' : 'Fri';
                    subtotalRow[dayLabel] = formatSecondsToHHMMSS(projectDayTotals[i - 1]);
                    subtotalRow[`${dayLabel} Comment`] = '';
                    projectTotalSeconds += projectDayTotals[i - 1];
                }
                subtotalRow['Total'] = formatSecondsToHHMMSS(projectTotalSeconds);
                
                excelData.push(subtotalRow);
            });

            // Add grand total row
            const grandTotalRow = {
                'Project Name': '',
                'Project Number': '',
                'Task': 'Grand Total'
            };
            
            let grandTotalSeconds = 0;
            for (let i = 1; i <= 5; i++) {
                const dayLabel = i === 1 ? 'Mon' : i === 2 ? 'Tue' : i === 3 ? 'Wed' : i === 4 ? 'Thu' : 'Fri';
                grandTotalRow[dayLabel] = formatSecondsToHHMMSS(dayTotals[i - 1]);
                grandTotalRow[`${dayLabel} Comment`] = '';
                grandTotalSeconds += dayTotals[i - 1];
            }
            grandTotalRow['Total'] = formatSecondsToHHMMSS(grandTotalSeconds);
            
            excelData.push(grandTotalRow);

            // Create workbook
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.json_to_sheet(excelData);

            // Set column widths
            ws['!cols'] = [
                { wch: 20 },  // Project Name
                { wch: 20 },  // Project Number
                { wch: 25 },  // Task
                { wch: 12 },  // Mon time
                { wch: 35 },  // Mon comment
                { wch: 12 },  // Tue time
                { wch: 35 },  // Tue comment
                { wch: 12 },  // Wed time
                { wch: 35 },  // Wed comment
                { wch: 12 },  // Thu time
                { wch: 35 },  // Thu comment
                { wch: 12 },  // Fri time
                { wch: 35 },  // Fri comment
                { wch: 12 }   // Total
            ];

            XLSX.utils.book_append_sheet(wb, ws, 'Timecard');
            
            const filename = `timecard_${formatDate(monday)}_${formatDate(friday)}.xlsx`;
            XLSX.writeFile(wb, filename);
            
            showAlert(`Exported to ${filename}`, 'success');
        }

        // Download complete history
        function downloadHistory() {
            // Prepare history data
            const historyData = {
                exportDate: new Date().toISOString(),
                exportDateFormatted: new Date().toLocaleString(),
                currentWeekData: {
                    weekStart: getWeekDates().monday.toISOString(),
                    weekEnd: getWeekDates().friday.toISOString(),
                    entries: timeEntries
                },
                projectNamesHistory: Array.from(projectNameHistory).sort(),
                projectNumbersHistory: Array.from(projectHistory).sort(),
                tasksHistory: Array.from(taskHistory).sort(),
                commentsHistory: Array.from(commentHistory).sort(),
                structuredHistory: {}
            };

            // Convert structured history Sets to Arrays
            Object.keys(structuredHistory).forEach(projName => {
                historyData.structuredHistory[projName] = {
                    projects: Array.from(structuredHistory[projName].projects || []).sort(),
                    tasks: Array.from(structuredHistory[projName].tasks || []).sort(),
                    comments: Array.from(structuredHistory[projName].comments || []).sort()
                };
            });

            // Create JSON file
            const jsonString = JSON.stringify(historyData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            a.download = `timecard_history_${timestamp}.json`;
            
            // Trigger download
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showAlert('History downloaded successfully! This file can be used for backup or analysis.', 'success');
        }

        // Clear history with stern warning
        function openHistoryEditor() {
            // Build project names dropdown
            let projectOptionsHTML = '<option value="">-- Select a Project Name --</option>';
            Array.from(projectNameHistory).sort().forEach(projName => {
                projectOptionsHTML += `<option value="${projName}">${projName}</option>`;
            });
            
            const dialogHTML = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 9999; display: flex; align-items: center; justify-content: center; overflow-y: auto; padding: 20px;" id="historyEditorDialog" onclick="if(event.target.id === 'historyEditorDialog') closeHistoryEditor();">
                    <div style="background: white; border-radius: 8px; padding: 25px; max-width: 900px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3);" onclick="event.stopPropagation();">
                        <h2 style="margin-top: 0; color: #366092;">‚úèÔ∏è Edit History</h2>
                        <p style="color: #666; margin-bottom: 20px;">Select a project name to edit its associated information (project numbers, tasks, and comments).</p>
                        
                        <div style="margin-bottom: 25px; padding: 15px; background: #f8f9fa; border-radius: 6px; border: 2px solid #366092; display:flex; gap:10px; align-items:center;">
                                    <div style="flex:1;">
                                        <label style="display: block; font-weight: bold; color: #366092; margin-bottom: 10px;">Select Project Name:</label>
                                        <select id="historyProjectSelector" onchange="loadProjectHistory()" style="width: 100%; padding: 10px; border: 2px solid #366092; border-radius: 4px; font-size: 16px; background: white;">
                                            ${projectOptionsHTML}
                                        </select>
                                    </div>
                                    <div style="width:1px; height:48px; background:rgba(0,0,0,0.06);"></div>
                                    <div style="display:flex; flex-direction:column; gap:8px;">
                                        <button onclick="openAddNewProjectDialog()" style="padding:8px 12px; background:#28a745; color:white; border:none; border-radius:4px; cursor:pointer; font-size:14px;">‚ûï Add New Project</button>
                                        <button onclick="document.getElementById('historyProjectSelector').value = ''; loadProjectHistory();" style="padding:8px 12px; background:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer; font-size:14px;">Clear</button>
                                    </div>
                                </div>
                        
                        <div id="projectHistoryContent" style="display: none;">
                            <div style="margin-bottom: 20px; padding: 15px; background: #e7f3ff; border-left: 4px solid #366092; border-radius: 4px;">
                                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                                    <strong style="color: #366092;">Project Name:</strong>
                                    <input type="text" id="editProjectName" style="flex: 1; padding: 8px; border: 2px solid #366092; border-radius: 4px; font-size: 14px;">
                                    <button onclick="deleteEntireProject()" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">üóëÔ∏è Delete Entire Project</button>
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 25px;">
                                <h3 style="color: #366092; border-bottom: 2px solid #366092; padding-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <span>Project Numbers (<span id="projNumCount">0</span>)</span>
                                    <button onclick="addNewProjectNumber()" style="padding: 5px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">‚ûï Add New</button>
                                </h3>
                                <div id="projectNumbersList" style="max-height: 200px; overflow-y: auto; padding: 10px 0;">
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 25px;">
                                <h3 style="color: #366092; border-bottom: 2px solid #366092; padding-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <span>Tasks (<span id="tasksCount">0</span>)</span>
                                    <button onclick="addNewTask()" style="padding: 5px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">‚ûï Add New</button>
                                </h3>
                                <div id="tasksList" style="max-height: 200px; overflow-y: auto; padding: 10px 0;">
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 25px;">
                                <h3 style="color: #366092; border-bottom: 2px solid #366092; padding-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <span>Comments (<span id="commentsCount">0</span>)</span>
                                    <button onclick="addNewComment()" style="padding: 5px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">‚ûï Add New</button>
                                </h3>
                                <div id="commentsList" style="max-height: 200px; overflow-y: auto; padding: 10px 0;">
                                </div>
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 10px; justify-content: space-between; margin-top: 20px; border-top: 1px solid #ddd; padding-top: 20px;">
                            <div style="display: flex; gap: 10px;">
                                <button onclick="downloadHistory()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">üìã Download History</button>
                                <button onclick="clearHistory()" style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">üßπ Clear All History</button>
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button onclick="closeHistoryEditor()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Cancel</button>
                                <button onclick="saveHistoryEdits()" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">üíæ Save Changes</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', dialogHTML);
        }

        function loadProjectHistory() {
            const selectedProject = document.getElementById('historyProjectSelector').value;
            const contentDiv = document.getElementById('projectHistoryContent');
            
            if (!selectedProject) {
                contentDiv.style.display = 'none';
                return;
            }
            
            contentDiv.style.display = 'block';
            document.getElementById('editProjectName').value = selectedProject;
            
            // Load project numbers
            const projectNumbers = structuredHistory[selectedProject]?.projects || new Set();
            const projNumList = document.getElementById('projectNumbersList');
            projNumList.innerHTML = '';
            document.getElementById('projNumCount').textContent = projectNumbers.size;
            
            if (projectNumbers.size === 0) {
                projNumList.innerHTML = '<p style="color: #999; font-style: italic; padding: 10px;">No project numbers saved yet</p>';
            } else {
                Array.from(projectNumbers).sort().forEach((item, index) => {
                    projNumList.innerHTML += `<div style="display: flex; gap: 10px; margin-bottom: 8px; align-items: center;">
                        <input type="text" value="${item}" class="projNum-input" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <button onclick="this.parentElement.remove(); updateCounts();" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">üóëÔ∏è</button>
                    </div>`;
                });
            }
            
            // Load tasks
            const tasks = structuredHistory[selectedProject]?.tasks || new Set();
            const tasksList = document.getElementById('tasksList');
            tasksList.innerHTML = '';
            document.getElementById('tasksCount').textContent = tasks.size;
            
            if (tasks.size === 0) {
                tasksList.innerHTML = '<p style="color: #999; font-style: italic; padding: 10px;">No tasks saved yet</p>';
            } else {
                Array.from(tasks).sort().forEach((item, index) => {
                    tasksList.innerHTML += `<div style="display: flex; gap: 10px; margin-bottom: 8px; align-items: center;">
                        <input type="text" value="${item}" class="task-input" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <button onclick="this.parentElement.remove(); updateCounts();" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">üóëÔ∏è</button>
                    </div>`;
                });
            }
            
            // Load comments
            const comments = structuredHistory[selectedProject]?.comments || new Set();
            const commentsList = document.getElementById('commentsList');
            commentsList.innerHTML = '';
            document.getElementById('commentsCount').textContent = comments.size;
            
            if (comments.size === 0) {
                commentsList.innerHTML = '<p style="color: #999; font-style: italic; padding: 10px;">No comments saved yet</p>';
            } else {
                Array.from(comments).sort().forEach((item, index) => {
                    commentsList.innerHTML += `<div style="display: flex; gap: 10px; margin-bottom: 8px; align-items: center;">
                        <input type="text" value="${item}" class="comment-input" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <button onclick="this.parentElement.remove(); updateCounts();" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">üóëÔ∏è</button>
                    </div>`;
                });
            }
        }

        function addNewProjectNumber() {
            const list = document.getElementById('projectNumbersList');
            const emptyMsg = list.querySelector('p');
            if (emptyMsg) emptyMsg.remove();
            
            list.insertAdjacentHTML('beforeend', `<div style="display: flex; gap: 10px; margin-bottom: 8px; align-items: center;">
                <input type="text" value="" class="projNum-input" placeholder="Enter project number" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                <button onclick="this.parentElement.remove(); updateCounts();" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">üóëÔ∏è</button>
            </div>`);
            updateCounts();
        }

        function addNewTask() {
            const list = document.getElementById('tasksList');
            const emptyMsg = list.querySelector('p');
            if (emptyMsg) emptyMsg.remove();
            
            list.insertAdjacentHTML('beforeend', `<div style="display: flex; gap: 10px; margin-bottom: 8px; align-items: center;">
                <input type="text" value="" class="task-input" placeholder="Enter task" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                <button onclick="this.parentElement.remove(); updateCounts();" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">üóëÔ∏è</button>
            </div>`);
            updateCounts();
        }

        function addNewComment() {
            const list = document.getElementById('commentsList');
            const emptyMsg = list.querySelector('p');
            if (emptyMsg) emptyMsg.remove();
            
            list.insertAdjacentHTML('beforeend', `<div style="display: flex; gap: 10px; margin-bottom: 8px; align-items: center;">
                <input type="text" value="" class="comment-input" placeholder="Enter comment" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                <button onclick="this.parentElement.remove(); updateCounts();" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">üóëÔ∏è</button>
            </div>`);
            updateCounts();
        }

        // Prompt to add a new project name to history and open its editor
        function addNewProjectName() {
            const newName = prompt('Enter new Project Name:');
            if (newName === null) return; // cancelled
            const trimmed = newName.trim();
            if (!trimmed) {
                showAlert('Project Name cannot be empty', 'error');
                return;
            }

            if (projectNameHistory.has(trimmed)) {
                showAlert('Project Name already exists in history', 'info');
                const selector = document.getElementById('historyProjectSelector');
                if (selector) {
                    selector.value = trimmed;
                    loadProjectHistory();
                }
                return;
            }

            // Add to history sets and structuredHistory
            projectNameHistory.add(trimmed);
            structuredHistory[trimmed] = {
                projects: new Set(),
                tasks: new Set(),
                comments: new Set()
            };

            saveHistory();
            updateDropdowns();

            // Refresh selector and open the new project's editor view
            const selector = document.getElementById('historyProjectSelector');
            if (selector) {
                const opt = document.createElement('option');
                opt.value = trimmed;
                opt.textContent = trimmed;
                selector.appendChild(opt);
                selector.value = trimmed;
                loadProjectHistory();
            }

            showAlert(`Project "${trimmed}" added to history`, 'success');
        }

        // Quick add a project number to the currently selected project in history editor
        function addNewProjectNumberQuick() {
            const selector = document.getElementById('historyProjectSelector');
            const selected = selector ? selector.value : '';
            if (!selected) {
                showAlert('Select a Project Name first (or add one).', 'error');
                return;
            }

            const pn = prompt('Enter new Project Number for ' + selected + ':');
            if (pn === null) return;
            const trimmed = pn.trim();
            if (!trimmed) { showAlert('Project Number cannot be empty', 'error'); return; }

            if (!structuredHistory[selected]) {
                structuredHistory[selected] = { projects: new Set(), tasks: new Set(), comments: new Set() };
            }
            structuredHistory[selected].projects.add(trimmed);
            projectHistory.add(trimmed);
            saveHistory();
            updateDropdowns();

            // If editor is open for this project, refresh its list
            loadProjectHistory();
            showAlert(`Project Number "${trimmed}" added to ${selected}`, 'success');
        }

        // Quick add a task to the currently selected project in history editor
        function addNewTaskQuick() {
            const selector = document.getElementById('historyProjectSelector');
            const selected = selector ? selector.value : '';
            if (!selected) {
                showAlert('Select a Project Name first (or add one).', 'error');
                return;
            }

            const t = prompt('Enter new Task for ' + selected + ':');
            if (t === null) return;
            const trimmed = t.trim();
            if (!trimmed) { showAlert('Task cannot be empty', 'error'); return; }

            if (!structuredHistory[selected]) {
                structuredHistory[selected] = { projects: new Set(), tasks: new Set(), comments: new Set() };
            }
            structuredHistory[selected].tasks.add(trimmed);
            taskHistory.add(trimmed);
            saveHistory();
            updateDropdowns();

            loadProjectHistory();
            showAlert(`Task "${trimmed}" added to ${selected}`, 'success');
        }

        // Open a modal to add project name, number and one task at once
        function openAddNewProjectDialog() {
            const html = `
                <div id="addNewProjectDialog" style="position: fixed; top:0; left:0; right:0; bottom:0; background: rgba(0,0,0,0.7); z-index:10000; display:flex; align-items:center; justify-content:center;">
                    <div style="background:white; padding:20px; border-radius:8px; width:420px; max-width:95%;">
                        <h3 style="margin-top:0; color:#366092;">Add New Project</h3>
                        <div style="margin-bottom:10px;"><label style="font-weight:600;">Project Name</label><input id="addProjName" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" /></div>
                        <div style="margin-bottom:10px;"><label style="font-weight:600;">Project Number</label><input id="addProjNumber" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" /></div>
                        <div style="margin-bottom:14px;"><label style="font-weight:600;">Task</label><input id="addProjTask" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" /></div>
                        <div style="display:flex; justify-content:flex-end; gap:8px;"><button onclick="document.getElementById('addNewProjectDialog').remove()" style="padding:8px 12px; background:#6c757d; color:white; border:none; border-radius:4px;">Cancel</button><button onclick="saveNewProjectFromDialog()" style="padding:8px 12px; background:#28a745; color:white; border:none; border-radius:4px;">Add</button></div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', html);
            setTimeout(() => document.getElementById('addProjName').focus(), 50);
        }

        function saveNewProjectFromDialog() {
            const name = document.getElementById('addProjName').value.trim();
            const number = document.getElementById('addProjNumber').value.trim();
            const task = document.getElementById('addProjTask').value.trim();

            if (!name) { showAlert('Project Name is required', 'error'); return; }
            if (!number && !task) { if (!confirm('No project number or task provided. Continue?')) return; }

            if (!projectNameHistory.has(name)) {
                projectNameHistory.add(name);
            }
            if (!structuredHistory[name]) {
                structuredHistory[name] = { projects: new Set(), tasks: new Set(), comments: new Set() };
            }
            if (number) {
                structuredHistory[name].projects.add(number);
                projectHistory.add(number);
            }
            if (task) {
                structuredHistory[name].tasks.add(task);
                taskHistory.add(task);
            }

            saveHistory();
            updateDropdowns();

            // Close dialog and open project editor with selection
            const dlg = document.getElementById('addNewProjectDialog'); if (dlg) dlg.remove();
            const selector = document.getElementById('historyProjectSelector');
            if (selector) {
                // ensure option exists
                let found = false;
                for (const opt of selector.options) { if (opt.value === name) { found = true; break; } }
                if (!found) {
                    const opt = document.createElement('option'); opt.value = name; opt.textContent = name; selector.appendChild(opt);
                }
                selector.value = name;
                loadProjectHistory();
            }

            showAlert('New project saved to history', 'success');
        }

        function updateCounts() {
            document.getElementById('projNumCount').textContent = document.querySelectorAll('.projNum-input').length;
            document.getElementById('tasksCount').textContent = document.querySelectorAll('.task-input').length;
            document.getElementById('commentsCount').textContent = document.querySelectorAll('.comment-input').length;
        }

        function deleteEntireProject() {
            const projectName = document.getElementById('historyProjectSelector').value;
            if (!projectName) return;
            
            const confirmation = prompt(`Are you sure you want to delete "${projectName}" and ALL its associated data?\n\nType "DELETE" to confirm:`);
            if (confirmation !== 'DELETE') {
                return;
            }
            
            // Remove from structured history
            delete structuredHistory[projectName];
            
            // Remove from project name history
            projectNameHistory.delete(projectName);
            
            // Close dialog and reopen to refresh
            closeHistoryEditor();
            saveHistory();
            updateDropdowns();
            showAlert(`Project "${projectName}" and all its data have been deleted.`, 'success');
            openHistoryEditor();
        }

        function saveHistoryEdits() {
            const selectedProject = document.getElementById('historyProjectSelector').value;
            if (!selectedProject) {
                showAlert('Please select a project to save changes.', 'error');
                return;
            }
            
            const newProjectName = document.getElementById('editProjectName').value.trim();
            if (!newProjectName) {
                showAlert('Project name cannot be empty!', 'error');
                return;
            }
            
            // Collect edited values for this project
            const newProjectNumbers = new Set();
            const newTasks = new Set();
            const newComments = new Set();
            
            document.querySelectorAll('.projNum-input').forEach(input => {
                const value = input.value.trim();
                if (value) newProjectNumbers.add(value);
            });
            
            document.querySelectorAll('.task-input').forEach(input => {
                const value = input.value.trim();
                if (value) newTasks.add(value);
            });
            
            document.querySelectorAll('.comment-input').forEach(input => {
                const value = input.value.trim();
                if (value) newComments.add(value);
            });
            
            // If project name changed, handle the rename
            if (newProjectName !== selectedProject) {
                // Remove old project name
                projectNameHistory.delete(selectedProject);
                delete structuredHistory[selectedProject];
                
                // Add new project name
                projectNameHistory.add(newProjectName);
            }
            
            // Update structured history for this project
            structuredHistory[newProjectName] = {
                projects: newProjectNumbers,
                tasks: newTasks,
                comments: newComments
            };
            
            // Rebuild global history sets from all structured histories
            projectHistory = new Set();
            taskHistory = new Set();
            commentHistory = new Set();
            
            Object.keys(structuredHistory).forEach(projName => {
                structuredHistory[projName].projects.forEach(p => projectHistory.add(p));
                structuredHistory[projName].tasks.forEach(t => taskHistory.add(t));
                structuredHistory[projName].comments.forEach(c => commentHistory.add(c));
            });
            
            // Save to localStorage
            saveHistory();
            
            // Update dropdowns
            updateDropdowns();
            
            showAlert('History updated successfully!', 'success');
            closeHistoryEditor();
        }

        function closeHistoryEditor() {
            const dialog = document.getElementById('historyEditorDialog');
            if (dialog) dialog.remove();
        }

        function clearHistory() {
            const warningMessage = `‚ö†Ô∏è CRITICAL WARNING ‚ö†Ô∏è

This action will PERMANENTLY DELETE ALL information stored in this program, including:

‚Ä¢ ALL timecard entries and recorded hours
‚Ä¢ ALL project names, numbers, and tasks
‚Ä¢ ALL comments and work history
‚Ä¢ ALL autocomplete suggestions

THIS CANNOT BE UNDONE OR RECOVERED!

Are you absolutely sure you want to proceed?

Type "DELETE ALL" (in capital letters) to confirm:`;

            const confirmation = prompt(warningMessage);
            
            if (confirmation === null) {
                // User cancelled
                return;
            }
            
            if (confirmation === 'DELETE ALL') {
                // Clear everything
                timeEntries = [];
                projectNameHistory.clear();
                projectHistory.clear();
                taskHistory.clear();
                commentHistory.clear();
                structuredHistory = {};
                localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem(HISTORY_KEY);
                updateDropdowns();
                updateSummary();
                resetTimer();
                closeHistoryEditor();
                showAlert('‚ö†Ô∏è All data has been permanently deleted!', 'error');
            } else {
                showAlert('Deletion cancelled - incorrect confirmation text entered', 'info');
            }
        }

        // Toggle all comments visibility
        function toggleAllComments(btn) {
            const comments = document.querySelectorAll('.comment');
            const isShowing = btn.classList.contains('active');
            
            if (isShowing) {
                comments.forEach(comment => comment.classList.remove('show'));
                btn.classList.remove('active');
                btn.innerHTML = 'üëÅÔ∏è Show Comments';
            } else {
                comments.forEach(comment => comment.classList.add('show'));
                btn.classList.add('active');
                btn.innerHTML = 'üëÅÔ∏è Hide Comments';
            }
        }

        // Toggle comments for a specific row
        function toggleRowComments(rowId, btn) {
            const comments = document.querySelectorAll(`.comment[data-comment-row="${rowId}"]`);
            const isShowing = btn.classList.contains('active');
            
            if (isShowing) {
                comments.forEach(comment => comment.classList.remove('show'));
                btn.classList.remove('active');
            } else {
                comments.forEach(comment => comment.classList.add('show'));
                btn.classList.add('active');
            }
        }

        // Switch between table and week view
        function switchView(view) {
            const tableViewBtn = document.getElementById('tableViewBtn');
            const weekViewBtn = document.getElementById('weekViewBtn');
            const tableViewContainer = document.getElementById('tableViewContainer');
            const weekViewContainer = document.getElementById('weekViewContainer');

            if (view === 'table') {
                tableViewBtn.classList.add('active');
                weekViewBtn.classList.remove('active');
                tableViewContainer.classList.add('active');
                weekViewContainer.classList.remove('active');
            } else {
                tableViewBtn.classList.remove('active');
                weekViewBtn.classList.add('active');
                tableViewContainer.classList.remove('active');
                weekViewContainer.classList.add('active');
                updateWeekView();
            }
        }

        // Update week view calendar
        function updateWeekView() {
            const calendarGrid = document.getElementById('calendarGrid');
            const currentDay = getCurrentWeekday();
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
            const dayLabels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'];

            let html = '';

            // Create columns for each day
            for (let dayIndex = 1; dayIndex <= 5; dayIndex++) {
                const isCurrentDay = dayIndex === currentDay;
                const dayEntries = [];

                // Collect all entries for this day
                timeEntries.forEach(entry => {
                    const timeStr = entry[`day${dayIndex}_hr`] || '00:00:00';
                    const clockTime = entry[`day${dayIndex}_clocktime`] || '';
                    const comment = entry[`day${dayIndex}_comment`] || '';

                    if (timeStr !== '00:00:00' && clockTime) {
                        // Parse clock times
                        const clockRanges = clockTime.split(',').map(range => range.trim());
                        clockRanges.forEach((range, rangeIndex) => {
                            const [startStr, endStr] = range.split('-').map(s => s.trim());
                            if (startStr && endStr) {
                                dayEntries.push({
                                    projectName: entry.projectNameFilter || 'Uncategorized',
                                    project: entry.project,
                                    task: entry.task,
                                    startTime: startStr,
                                    endTime: endStr,
                                    comment: comment,
                                    dayIndex: dayIndex,
                                    isLastBlock: rangeIndex === clockRanges.length - 1
                                });
                            }
                        });
                    }
                });

                // If timer is running and this is the current day, handle it ONCE after all blocks are collected
                if (startTime !== null) {
                    const todayIndex = getCurrentWeekday();
                    if (dayIndex === todayIndex) {
                        const runningProject = document.getElementById('projectNameFilter').value.trim() || (lastActiveTask && lastActiveTask.projectNameFilter) || 'Running Task';
                        const runningProjectNum = document.getElementById('projectName').value.trim() || (lastActiveTask && lastActiveTask.project) || '';
                        const runningTask = document.getElementById('taskName').value.trim() || (lastActiveTask && lastActiveTask.task) || '';
                        const startClock = formatClockTime(new Date(startTime));
                        const nowClock = formatClockTime(new Date());
                        const liveComment = (document.getElementById('comment') && document.getElementById('comment').value.trim()) || '';
                        
                        // Check if we're continuing from the last block of this entry
                        const lastBlock = dayEntries.find(e => 
                            e.projectName === runningProject && 
                            e.task === runningTask && 
                            e.dayIndex === dayIndex &&
                            e.isLastBlock
                        );
                        
                        if (lastBlock && isContinuingLastBlock) {
                            // User chose to continue from last block - update its end time and mark as running
                            lastBlock.endTime = nowClock;
                            lastBlock.running = true;
                            lastBlock.comment = liveComment || lastBlock.comment || 'Currently running';
                        } else {
                            // No matching last block, add new running block
                            dayEntries.push({
                                projectName: runningProject,
                                project: runningProjectNum,
                                task: runningTask,
                                startTime: startClock,
                                endTime: nowClock,
                                comment: liveComment || 'Currently running',
                                dayIndex: dayIndex,
                                running: true
                            });
                        }
                    }
                }

                // Calculate day total
                let dayTotalSeconds = 0;
                timeEntries.forEach(entry => {
                    dayTotalSeconds += parseHHMMSSToSeconds(entry[`day${dayIndex}_hr`] || '00:00:00');
                });
                const dayTotal = formatSecondsToHHMMSS(dayTotalSeconds);

                // Build day column
                html += `
                    <div class="day-column">
                        <div class="day-header ${isCurrentDay ? 'current' : ''}">
                            ${days[dayIndex - 1]}
                        </div>
                        <div class="timeline">
                            <div class="time-labels">
                                ${generateTimeLabels()}
                            </div>
                            <div class="time-blocks clickable" onclick="addNewTimeEntry(event, ${dayIndex})">
                                ${generateTimeBlocks(dayEntries)}
                            </div>
                        </div>
                        <div class="day-total">${dayTotal}</div>
                    </div>
                `;
            }

            calendarGrid.innerHTML = html;
        }

        // Generate time labels with dynamic hours
        function generateTimeLabels() {
            let html = '';
            const startHour = parseInt(document.getElementById('startHourSelect')?.value || 7);
            const endHour = parseInt(document.getElementById('endHourSelect')?.value || 18);
            const totalHours = endHour - startHour;
            
            for (let hour = startHour; hour < endHour; hour++) {
                const position = ((hour - startHour) / totalHours) * 100;
                const time12h = hour > 12 ? `${hour - 12} PM` : (hour === 12 ? '12 PM' : (hour === 0 ? '12 AM' : `${hour} AM`));
                html += `<div class="time-label" style="top: ${position}%">${time12h}</div>`;
            }
            
            return html;
        }

        // Parse time string to minutes from start of day
        function parseTimeToMinutes(timeStr) {
            // Parse formats like "9:30 AM" or "1:45 PM"
            const match = timeStr.match(/(\d+):(\d+)\s*(AM|PM)/i);
            if (!match) return 0;
            
            let hours = parseInt(match[1]);
            const minutes = parseInt(match[2]);
            const period = match[3].toUpperCase();
            
            if (period === 'PM' && hours !== 12) hours += 12;
            if (period === 'AM' && hours === 12) hours = 0;
            
            return hours * 60 + minutes;
        }

        // Generate time blocks for entries
        function generateTimeBlocks(entries) {
            if (entries.length === 0) {
                return '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #999; font-size: 0.9em;">No entries</div>';
            }

            let html = '';
            const startHour = parseInt(document.getElementById('startHourSelect')?.value || 7);
            const endHour = parseInt(document.getElementById('endHourSelect')?.value || 18);
            const totalMinutes = (endHour - startHour) * 60;

            // Build block objects with start/end minutes and filter valid ones
            const blocks = entries.map(entry => {
                const s = parseTimeToMinutes(entry.startTime) - (startHour * 60);
                const e = parseTimeToMinutes(entry.endTime) - (startHour * 60);
                return Object.assign({}, entry, { startMinutes: s, endMinutes: e });
            }).filter(b => !(b.startMinutes < 0 || b.endMinutes > totalMinutes || b.startMinutes >= b.endMinutes));

            if (blocks.length === 0) return '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #999; font-size: 0.9em;">No entries</div>';

            // Sort by start then by longer duration
            blocks.sort((a, b) => a.startMinutes - b.startMinutes || b.endMinutes - a.endMinutes);

            // Interval partitioning: assign columns so overlapping blocks share different columns
            const columnEnds = []; // end minute per column
            const placements = []; // {block, col}

            blocks.forEach(b => {
                let placed = false;
                for (let c = 0; c < columnEnds.length; c++) {
                    if (b.startMinutes >= columnEnds[c]) {
                        placements.push({ block: b, col: c });
                        columnEnds[c] = b.endMinutes;
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    const newCol = columnEnds.length;
                    columnEnds.push(b.endMinutes);
                    placements.push({ block: b, col: newCol });
                }
            });

            const numCols = Math.max(1, columnEnds.length);
            const gapPercent = 1.5; // small gap between columns
            const totalGap = gapPercent * (numCols - 1);
            const colWidth = (100 - totalGap) / numCols;

            const colors = [
                'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                'linear-gradient(135deg, #30cfd0 0%, #330867 100%)'
            ];

            // Precompute overlap counts so isolated blocks can span full width
            const overlapCounts = new Array(blocks.length).fill(0);
            for (let i = 0; i < blocks.length; i++) {
                for (let j = 0; j < blocks.length; j++) {
                    if (i === j) continue;
                    if (blocks[i].startMinutes < blocks[j].endMinutes && blocks[j].startMinutes < blocks[i].endMinutes) {
                        overlapCounts[i]++;
                    }
                }
            }

            placements.forEach(place => {
                const entry = place.block;
                const startMinutes = entry.startMinutes;
                const endMinutes = entry.endMinutes;
                const topPercent = (startMinutes / totalMinutes) * 100;
                const heightPercent = ((endMinutes - startMinutes) / totalMinutes) * 100;
                let leftPercent = place.col * (colWidth + gapPercent);
                let widthPercent = colWidth;

                // If this block doesn't overlap any other block, span full available width
                const blockIndex = blocks.indexOf(entry);
                if (blockIndex >= 0 && overlapCounts[blockIndex] === 0 && numCols > 1) {
                    leftPercent = 0;
                    widthPercent = 100;
                }
                const colorIndex = (entry.projectName || ' ')[0].charCodeAt(0) % colors.length;

                const runningClass = entry.running ? ' time-block-running' : '';
                const runningStyle = entry.running ? 'box-shadow: 0 6px 18px rgba(0,0,0,0.45), 0 0 10px rgba(255,255,255,0.12); border: 2px dashed rgba(255,255,255,0.6);' : '';
                
                // For running timer, show hourglass with details
                if (entry.running) {
                    html += `
                        <div class="time-block${runningClass}" 
                             data-project="${entry.projectName}"
                             data-task="${entry.task}"
                             data-start="${entry.startTime}"
                             data-end="${entry.endTime}"
                             data-day="${entry.dayIndex}"
                             data-comment="${(entry.comment || '').replace(/"/g, '&quot;')}"
                             style="top: ${topPercent}%; height: ${heightPercent}%; left: ${leftPercent}%; width: ${widthPercent}%; background: ${colors[colorIndex]}; ${runningStyle} cursor: default; position: relative;"
                             title="${entry.projectName} - ${entry.task}\nTimer running: ${entry.startTime} - ${entry.endTime}\n${entry.comment || 'No comment'}">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3em; animation: pulse 2s ease-in-out infinite; z-index: 10;">‚è≥</div>
                            <div class="time-block-content" style="position: relative; z-index: 5; opacity: 0.85;">
                                <div class="time-block-project">${entry.projectName}</div>
                                <div class="time-block-task">${entry.task} (running)</div>
                                <div class="time-block-duration">${entry.startTime} - ${entry.endTime}</div>
                            </div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="time-block${runningClass}" 
                             draggable="true"
                             data-project="${entry.projectName}"
                             data-task="${entry.task}"
                             data-start="${entry.startTime}"
                             data-end="${entry.endTime}"
                             data-day="${entry.dayIndex}"
                             data-comment="${(entry.comment || '').replace(/"/g, '&quot;')}"
                             style="top: ${topPercent}%; height: ${heightPercent}%; left: ${leftPercent}%; width: ${widthPercent}%; background: ${colors[colorIndex]}; ${runningStyle}"
                             title="${entry.projectName} - ${entry.task}\n${entry.startTime} - ${entry.endTime}\n${entry.comment || 'No comment'}\nClick to edit, drag to move"
                             onmousedown="startDragTimeBlock(event, this)"
                             ondragstart="return false;">
                            <div class="resize-handle top" onmousedown="startResize(event, this.parentElement, 'top')"></div>
                            <button class="time-block-delete" onclick="deleteTimeBlock(event, this.parentElement)" title="Delete this entry">√ó</button>
                            <button class="time-block-record" onclick="resumeEntryByKeys('${(entry.projectName||'').replace(/'/g, "\\'")}', '${(entry.task||'').replace(/'/g, "\\'")}', '${entry.startTime}', '${entry.endTime}', ${entry.dayIndex})" title="Resume this block">‚ñ∂</button>
                            <div class="time-block-content" onclick="editTimeBlock(event, this.parentElement)">
                                <div class="time-block-project">${entry.projectName}</div>
                                <div class="time-block-task">${entry.task}${entry.running ? ' (running)' : ''}</div>
                                <div class="time-block-duration">${entry.startTime} - ${entry.endTime}</div>
                            </div>
                            <div class="resize-handle bottom" onmousedown="startResize(event, this.parentElement, 'bottom')"></div>
                        </div>
                    `;
                }
            });

            return html;
        }

        // Set all day work hours (8 AM - 5 PM)
        function setWorkHours() {
            document.getElementById('startHourSelect').value = '8';
            document.getElementById('endHourSelect').value = '17';
            updateWeekView();
        }

        // Set 1st half (8 AM - 12 PM)
        function setFirstHalf() {
            document.getElementById('startHourSelect').value = '8';
            document.getElementById('endHourSelect').value = '12';
            updateWeekView();
        }

        // Set 2nd half (12 PM - 5 PM)
        function setSecondHalf() {
            document.getElementById('startHourSelect').value = '12';
            document.getElementById('endHourSelect').value = '17';
            updateWeekView();
        }

        // Drag and drop functionality for time blocks
        let draggedBlock = null;
        let dragStartY = 0;
        let dragStartTop = 0;
        let isBlockDragging = false;

        function startDragTimeBlock(e, block) {
            e.preventDefault();
            draggedBlock = block;
            dragStartY = e.clientY;
            dragStartTop = parseFloat(block.style.top);
            isBlockDragging = false;

            block.classList.add('dragging');

            document.addEventListener('mousemove', dragTimeBlock);
            document.addEventListener('mouseup', stopDragTimeBlock);
        }

        function dragTimeBlock(e) {
            if (!draggedBlock) return;
            
            isBlockDragging = true;
            const timeline = draggedBlock.parentElement;
            const timelineRect = timeline.getBoundingClientRect();
            const deltaY = e.clientY - dragStartY;
            const deltaPercent = (deltaY / timelineRect.height) * 100;
            let newTop = dragStartTop + deltaPercent;

            // Constrain within timeline
            const blockHeight = parseFloat(draggedBlock.style.height);
            newTop = Math.max(0, Math.min(100 - blockHeight, newTop));

            // Snap to 30-minute intervals
            const startHour = parseInt(document.getElementById('startHourSelect')?.value || 8);
            const endHour = parseInt(document.getElementById('endHourSelect')?.value || 17);
            const totalMinutes = (endHour - startHour) * 60;
            
            // Convert percent to minutes
            const topMinutes = (newTop / 100) * totalMinutes;
            
            // Snap to nearest 30-minute interval
            const snappedMinutes = Math.round(topMinutes / 30) * 30;
            
            // Convert back to percent
            const snappedTop = (snappedMinutes / totalMinutes) * 100;

            draggedBlock.style.top = snappedTop + '%';
        }

        function stopDragTimeBlock(e) {
            if (!draggedBlock) return;

            document.removeEventListener('mousemove', dragTimeBlock);
            document.removeEventListener('mouseup', stopDragTimeBlock);

            if (isBlockDragging) {
                // Calculate new time based on position
                const startHour = parseInt(document.getElementById('startHourSelect')?.value || 8);
                const endHour = parseInt(document.getElementById('endHourSelect')?.value || 17);
                const totalMinutes = (endHour - startHour) * 60;

                const topPercent = parseFloat(draggedBlock.style.top);
                const heightPercent = parseFloat(draggedBlock.style.height);

                const startMinutes = (topPercent / 100) * totalMinutes + (startHour * 60);
                const endMinutes = ((topPercent + heightPercent) / 100) * totalMinutes + (startHour * 60);

                const newStartTime = formatMinutesToTime(startMinutes);
                const newEndTime = formatMinutesToTime(endMinutes);

                // Get entry details
                const projectName = draggedBlock.dataset.project;
                const task = draggedBlock.dataset.task;
                const oldStartTime = draggedBlock.dataset.start;
                const oldEndTime = draggedBlock.dataset.end;

                // Update the entry in timeEntries
                updateTimeEntry(projectName, task, oldStartTime, oldEndTime, newStartTime, newEndTime);

                showAlert(`Time updated: ${oldStartTime} - ${oldEndTime} ‚Üí ${newStartTime} - ${newEndTime}`, 'success');
            }

            draggedBlock.classList.remove('dragging');
            draggedBlock = null;
            isBlockDragging = false;
        }

        // Format minutes to time string (e.g., 540 -> "9:00 AM")
        function formatMinutesToTime(totalMinutes) {
            // Snap to nearest 30 minutes
            totalMinutes = Math.round(totalMinutes / 30) * 30;
            
            let hours = Math.floor(totalMinutes / 60);
            let minutes = totalMinutes % 60;

            const period = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours > 12 ? hours - 12 : (hours === 0 ? 12 : hours);
            const displayMinutes = String(minutes).padStart(2, '0');

            return `${displayHours}:${displayMinutes} ${period}`;
        }

        // Update time entry with new times
        function updateTimeEntry(projectName, task, oldStart, oldEnd, newStart, newEnd) {
            const currentDay = getCurrentWeekday();

            // Find the entry
            const entry = timeEntries.find(e => 
                e.projectNameFilter === projectName && e.task === task
            );

            if (!entry) return;

            const clockTimeKey = `day${currentDay}_clocktime`;
            const oldClockTime = entry[clockTimeKey] || '';

            // Replace the old time range with new one
            const oldRange = `${oldStart} - ${oldEnd}`;
            const newRange = `${newStart} - ${newEnd}`;

            if (oldClockTime.includes(oldRange)) {
                entry[clockTimeKey] = oldClockTime.replace(oldRange, newRange);

                // Recalculate total hours for the day
                const clockRanges = entry[clockTimeKey].split(',').map(r => r.trim());
                let totalSeconds = 0;

                clockRanges.forEach(range => {
                    const [start, end] = range.split('-').map(s => s.trim());
                    if (start && end) {
                        const startMin = parseTimeToMinutes(start);
                        const endMin = parseTimeToMinutes(end);
                        totalSeconds += (endMin - startMin) * 60;
                    }
                });

                entry[`day${currentDay}_hr`] = formatSecondsToHHMMSS(totalSeconds);

                saveData();
                updateSummary();
                updateWeekView();
            }
        }

        // Resize functionality for time blocks
        let resizingBlock = null;
        let resizeDirection = null;
        let resizeStartY = 0;
        let resizeStartTop = 0;
        let resizeStartHeight = 0;

        function startResize(e, block, direction) {
            e.stopPropagation();
            e.preventDefault();
            
            resizingBlock = block;
            resizeDirection = direction;
            resizeStartY = e.clientY;
            resizeStartTop = parseFloat(block.style.top);
            resizeStartHeight = parseFloat(block.style.height);

            block.classList.add('dragging');

            document.addEventListener('mousemove', resizeTimeBlock);
            document.addEventListener('mouseup', stopResize);
        }

        function resizeTimeBlock(e) {
            if (!resizingBlock) return;

            const timeline = resizingBlock.parentElement;
            const timelineRect = timeline.getBoundingClientRect();
            const deltaY = e.clientY - resizeStartY;
            const deltaPercent = (deltaY / timelineRect.height) * 100;

            const startHour = parseInt(document.getElementById('startHourSelect')?.value || 8);
            const endHour = parseInt(document.getElementById('endHourSelect')?.value || 17);
            const totalMinutes = (endHour - startHour) * 60;

            if (resizeDirection === 'top') {
                let newTop = resizeStartTop + deltaPercent;
                let newHeight = resizeStartHeight - deltaPercent;

                // Snap top to 30-minute intervals
                const topMinutes = (newTop / 100) * totalMinutes;
                const snappedTopMinutes = Math.round(topMinutes / 30) * 30;
                newTop = (snappedTopMinutes / totalMinutes) * 100;

                // Recalculate height based on snapped top
                newHeight = resizeStartTop + resizeStartHeight - newTop;

                // Snap height to 30-minute intervals
                const heightMinutes = (newHeight / 100) * totalMinutes;
                const snappedHeightMinutes = Math.max(30, Math.round(heightMinutes / 30) * 30); // Minimum 30 minutes
                newHeight = (snappedHeightMinutes / totalMinutes) * 100;

                // Constrain
                newTop = Math.max(0, newTop);
                
                if (newTop + newHeight > 100) {
                    newHeight = 100 - newTop;
                }

                resizingBlock.style.top = newTop + '%';
                resizingBlock.style.height = newHeight + '%';
            } else {
                let newHeight = resizeStartHeight + deltaPercent;
                
                // Snap height to 30-minute intervals
                const heightMinutes = (newHeight / 100) * totalMinutes;
                const snappedHeightMinutes = Math.max(30, Math.round(heightMinutes / 30) * 30); // Minimum 30 minutes
                newHeight = (snappedHeightMinutes / totalMinutes) * 100;
                
                // Constrain
                if (resizeStartTop + newHeight > 100) {
                    newHeight = 100 - resizeStartTop;
                }

                resizingBlock.style.height = newHeight + '%';
            }
        }

        function stopResize(e) {
            if (!resizingBlock) return;

            document.removeEventListener('mousemove', resizeTimeBlock);
            document.removeEventListener('mouseup', stopResize);

            // Calculate new times
            const startHour = parseInt(document.getElementById('startHourSelect')?.value || 8);
            const endHour = parseInt(document.getElementById('endHourSelect')?.value || 17);
            const totalMinutes = (endHour - startHour) * 60;

            const topPercent = parseFloat(resizingBlock.style.top);
            const heightPercent = parseFloat(resizingBlock.style.height);

            const startMinutes = (topPercent / 100) * totalMinutes + (startHour * 60);
            const endMinutes = ((topPercent + heightPercent) / 100) * totalMinutes + (startHour * 60);

            const newStartTime = formatMinutesToTime(startMinutes);
            const newEndTime = formatMinutesToTime(endMinutes);

            // Get entry details
            const projectName = resizingBlock.dataset.project;
            const task = resizingBlock.dataset.task;
            const oldStartTime = resizingBlock.dataset.start;
            const oldEndTime = resizingBlock.dataset.end;

            // Update the entry
            updateTimeEntry(projectName, task, oldStartTime, oldEndTime, newStartTime, newEndTime);

            showAlert(`Time resized: ${oldStartTime} - ${oldEndTime} ‚Üí ${newStartTime} - ${newEndTime}`, 'success');

            resizingBlock.classList.remove('dragging');
            resizingBlock = null;
            resizeDirection = null;
        }

        // Edit time block details
        function editTimeBlock(e, block) {
            e.stopPropagation();
            
            // Don't edit if we're dragging
            if (isBlockDragging) return;
            
            const projectName = block.dataset.project;
            const task = block.dataset.task;
            const startTime = block.dataset.start;
            const endTime = block.dataset.end;
            const dayIndex = parseInt(block.dataset.day);
            const currentComment = block.dataset.comment.replace(/&quot;/g, '"');
            
            // Get current entry to find project number
            const entry = timeEntries.find(e => 
                e.projectNameFilter === projectName && e.task === task
            );
            const projectNumber = entry ? entry.project : '';
            
            // Build history datalists
            let projectNameOptions = '';
            let projectNumberOptions = '';
            let taskOptions = '';
            
            projectNameHistory.forEach(item => {
                projectNameOptions += `<option value="${item}">`;
            });
            
            projectHistory.forEach(item => {
                projectNumberOptions += `<option value="${item}">`;
            });
            
            taskHistory.forEach(item => {
                taskOptions += `<option value="${item}">`;
            });
            
            // Create edit dialog
            const dialogHTML = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 9999; display: flex; align-items: center; justify-content: center;" id="editDialog" onclick="if(event.target.id === 'editDialog') this.remove();">
                    <div style="background: white; border-radius: 8px; padding: 20px; max-width: 500px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.3);" onclick="event.stopPropagation();">
                        <h3 style="margin-top: 0; color: #333;">Edit Time Entry</h3>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #555;">Project Name:</label>
                            <input type="text" id="editProjectName" value="${projectName}" list="editProjectNameList" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <datalist id="editProjectNameList">${projectNameOptions}</datalist>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #555;">Project Number:</label>
                            <input type="text" id="editProjectNumber" value="${projectNumber}" list="editProjectNumberList" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <datalist id="editProjectNumberList">${projectNumberOptions}</datalist>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #555;">Task:</label>
                            <input type="text" id="editTask" value="${task}" list="editTaskList" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <datalist id="editTaskList">${taskOptions}</datalist>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #555;">Start Time:</label>
                            <input type="text" id="editStartTime" value="${startTime}" placeholder="9:00 AM" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #555;">End Time:</label>
                            <input type="text" id="editEndTime" value="${endTime}" placeholder="5:00 PM" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                        </div>
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #555;">Comment:</label>
                            <textarea id="editComment" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; min-height: 60px;">${currentComment}</textarea>
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button onclick="document.getElementById('editDialog').remove()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600;">Cancel</button>
                            <button onclick="saveTimeBlockEdit('${projectName}', '${task}', '${startTime}', '${endTime}', ${dayIndex}, '${projectNumber}')" style="padding: 8px 16px; background: #366092; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600;">Save</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', dialogHTML);
        }

        // Save edited time block
        function saveTimeBlockEdit(oldProjectName, oldTask, oldStartTime, oldEndTime, dayIndex, oldProjectNumber) {
            const newProjectName = document.getElementById('editProjectName').value.trim();
            const newProjectNumber = document.getElementById('editProjectNumber').value.trim();
            const newTask = document.getElementById('editTask').value.trim();
            const newStartTime = document.getElementById('editStartTime').value.trim();
            const newEndTime = document.getElementById('editEndTime').value.trim();
            const newComment = document.getElementById('editComment').value.trim();
            
            if (!newProjectName || !newProjectNumber || !newTask || !newStartTime || !newEndTime) {
                showAlert('Please fill in all required fields', 'error');
                return;
            }
            
            // Find the entry
            const entry = timeEntries.find(e => 
                e.projectNameFilter === oldProjectName && e.task === oldTask
            );
            
            if (!entry) {
                showAlert('Entry not found', 'error');
                return;
            }
            
            const clockTimeKey = `day${dayIndex}_clocktime`;
            const commentKey = `day${dayIndex}_comment`;
            const oldClockTime = entry[clockTimeKey] || '';
            
            // Replace the old time range with new one
            const oldRange = `${oldStartTime} - ${oldEndTime}`;
            const newRange = `${newStartTime} - ${newEndTime}`;
            
            if (oldClockTime.includes(oldRange)) {
                entry[clockTimeKey] = oldClockTime.replace(oldRange, newRange);
                
                // Update comment if changed
                if (newComment !== entry[commentKey]) {
                    entry[commentKey] = newComment;
                }
                
                // Update project number if only it changed (not name or task)
                if (newProjectNumber !== oldProjectNumber && newProjectName === oldProjectName && newTask === oldTask) {
                    entry.project = newProjectNumber;
                }
                
                // If project name, number, or task changed significantly, we need to update or create new entry
                if (newProjectName !== oldProjectName || (newProjectNumber !== oldProjectNumber && newProjectName !== oldProjectName) || newTask !== oldTask) {
                    // Remove old time from old entry
                    entry[clockTimeKey] = entry[clockTimeKey].split(',').map(r => r.trim()).filter(r => r !== newRange).join(', ');
                    
                    // Find or create new entry
                    let newEntry = timeEntries.find(e => 
                        e.projectNameFilter === newProjectName && e.project === newProjectNumber && e.task === newTask
                    );
                    
                    if (!newEntry) {
                        newEntry = { 
                            projectNameFilter: newProjectName, 
                            project: newProjectNumber,
                            task: newTask 
                        };
                        for (let i = 1; i <= 5; i++) {
                            newEntry[`day${i}_hr`] = '00:00:00';
                            newEntry[`day${i}_comment`] = '';
                            newEntry[`day${i}_clocktime`] = '';
                        }
                        timeEntries.push(newEntry);
                    }
                    
                    // Add time to new entry
                    const newClockTime = newEntry[clockTimeKey] || '';
                    newEntry[clockTimeKey] = newClockTime ? `${newClockTime}, ${newRange}` : newRange;
                    if (newComment) {
                        newEntry[commentKey] = newComment;
                    }
                }
                
                // Recalculate total hours for affected entries
                [entry].forEach(e => {
                    if (!e[clockTimeKey]) return;
                    const clockRanges = e[clockTimeKey].split(',').map(r => r.trim()).filter(r => r);
                    let totalSeconds = 0;
                    
                    clockRanges.forEach(range => {
                        const [start, end] = range.split('-').map(s => s.trim());
                        if (start && end) {
                            const startMin = parseTimeToMinutes(start);
                            const endMin = parseTimeToMinutes(end);
                            totalSeconds += (endMin - startMin) * 60;
                        }
                    });
                    
                    e[`day${dayIndex}_hr`] = formatSecondsToHHMMSS(totalSeconds);
                });
                
                saveData();
                updateSummary();
                updateWeekView();
                document.getElementById('editDialog').remove();
                showAlert('Time entry updated successfully', 'success');
            }
        }

        // Delete time block
        function deleteTimeBlock(e, block) {
            e.stopPropagation();
            
            const projectName = block.dataset.project;
            const task = block.dataset.task;
            const startTime = block.dataset.start;
            const endTime = block.dataset.end;
            const dayIndex = parseInt(block.dataset.day);
            
            const confirmMsg = `WARNING: This will permanently delete this time entry!\n\n${projectName} - ${task}\n${startTime} - ${endTime}\n\nType "Delete" to confirm:`;
            const userInput = prompt(confirmMsg, '');
            
            if (userInput !== 'Delete') {
                if (userInput !== null) {
                    showAlert('Delete cancelled - you must type "Delete" exactly to confirm', 'error');
                }
                return;
            }
            
            // Find the entry
            const entry = timeEntries.find(e => 
                e.projectNameFilter === projectName && e.task === task
            );
            
            if (!entry) {
                showAlert('Entry not found', 'error');
                return;
            }
            
            const clockTimeKey = `day${dayIndex}_clocktime`;
            const oldClockTime = entry[clockTimeKey] || '';
            
            // Remove the time range
            const rangeToRemove = `${startTime} - ${endTime}`;
            const clockRanges = oldClockTime.split(',').map(r => r.trim());
            const updatedRanges = clockRanges.filter(r => r !== rangeToRemove);
            
            entry[clockTimeKey] = updatedRanges.join(', ');
            
            // Recalculate total hours
            let totalSeconds = 0;
            updatedRanges.forEach(range => {
                const [start, end] = range.split('-').map(s => s.trim());
                if (start && end) {
                    const startMin = parseTimeToMinutes(start);
                    const endMin = parseTimeToMinutes(end);
                    totalSeconds += (endMin - startMin) * 60;
                }
            });
            
            entry[`day${dayIndex}_hr`] = formatSecondsToHHMMSS(totalSeconds);
            
            // If no more time entries for this task, remove the entry
            let hasAnyTime = false;
            for (let i = 1; i <= 5; i++) {
                if (entry[`day${i}_hr`] && entry[`day${i}_hr`] !== '00:00:00') {
                    hasAnyTime = true;
                    break;
                }
            }
            
            if (!hasAnyTime) {
                const entryIndex = timeEntries.indexOf(entry);
                if (entryIndex > -1) {
                    timeEntries.splice(entryIndex, 1);
                }
            }
            
            saveData();
            updateSummary();
            updateWeekView();
            showAlert('Time entry deleted', 'success');
        }

        // Add new time entry by clicking on timeline
        function addNewTimeEntry(e, dayIndex) {
            // Don't trigger if clicking on existing block
            if (e.target.classList.contains('time-block') || 
                e.target.closest('.time-block') ||
                e.target.classList.contains('resize-handle')) {
                return;
            }

            const timeline = e.currentTarget;
            const rect = timeline.getBoundingClientRect();
            const clickY = e.clientY - rect.top;
            const clickPercent = (clickY / rect.height) * 100;

            const startHour = parseInt(document.getElementById('startHourSelect')?.value || 8);
            const endHour = parseInt(document.getElementById('endHourSelect')?.value || 17);
            const totalMinutes = (endHour - startHour) * 60;

            // Calculate clicked time (default 1 hour block)
            const clickMinutes = (clickPercent / 100) * totalMinutes + (startHour * 60);
            const startTime = formatMinutesToTime(clickMinutes);
            const endTime = formatMinutesToTime(clickMinutes + 60); // Default 1 hour

            // Get current form values
            const projectNameFilter = document.getElementById('projectNameFilter').value.trim();
            const project = document.getElementById('projectName').value.trim();
            const task = document.getElementById('taskName').value.trim();
            const comment = document.getElementById('comment').value.trim();

            if (!projectNameFilter || !project || !task) {
                showAlert('Please fill in Project Name, Project Number, and Task Name first', 'error');
                return;
            }

            // Find or create entry
            let entry = timeEntries.find(e => 
                e.projectNameFilter === projectNameFilter && 
                e.project === project && 
                e.task === task
            );

            if (!entry) {
                entry = { 
                    projectNameFilter, 
                    project, 
                    task 
                };
                for (let i = 1; i <= 5; i++) {
                    entry[`day${i}_hr`] = '00:00:00';
                    entry[`day${i}_comment`] = '';
                    entry[`day${i}_clocktime`] = '';
                }
                timeEntries.push(entry);
            }

            // Add new time entry
            const clockTimeKey = `day${dayIndex}_clocktime`;
            const existingClockTime = entry[clockTimeKey] || '';
            const newClockTime = `${startTime} - ${endTime}`;
            
            if (existingClockTime) {
                entry[clockTimeKey] = `${existingClockTime}, ${newClockTime}`;
            } else {
                entry[clockTimeKey] = newClockTime;
            }

            // Add comment if provided
            if (comment) {
                const commentKey = `day${dayIndex}_comment`;
                const existingComment = entry[commentKey] || '';
                if (existingComment) {
                    entry[commentKey] = `${existingComment}; ${comment}`;
                } else {
                    entry[commentKey] = comment;
                }
            }

            // Calculate duration and add to total
            const durationMinutes = 60; // 1 hour default
            const durationSeconds = durationMinutes * 60;
            const currentSeconds = parseHHMMSSToSeconds(entry[`day${dayIndex}_hr`] || '00:00:00');
            entry[`day${dayIndex}_hr`] = formatSecondsToHHMMSS(currentSeconds + durationSeconds);

            saveData();
            updateSummary();
            updateWeekView();
            
            showAlert(`Added ${newClockTime} to ${projectNameFilter} - ${task}`, 'success');
        }

        // Setup page protection to prevent accidental data loss
        function setupPageProtection() {
            // Auto-save timer on page close/refresh
            window.addEventListener('beforeunload', function (e) {
                // Save current form values as last task (even if timer not running)
                const projectNameFilter = document.getElementById('projectNameFilter').value.trim();
                const project = document.getElementById('projectName').value.trim();
                const task = document.getElementById('taskName').value.trim();
                
                if (projectNameFilter || project || task) {
                    lastActiveTask = {
                        projectNameFilter: projectNameFilter,
                        project: project,
                        task: task
                    };
                    saveLastTask();
                }
                
                // If timer is running, stop it and save
                if (startTime !== null) {
                    // Stop timer and save data
                    autoStopTimer();
                }
                // Don't show warning - just save and close
            });
        }
    </script>
</body>
</html>

